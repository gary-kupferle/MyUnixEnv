Fish Shell Notes

For article
- create example script in Fish, Bash, and Node
  that lists files containing given text in their name
  in tree form that colors file types differently
  (ex. red for .js, blue for .scss, ...)
  * maybe make colors configurable

Help
- help command-name
  * opens browser to fish shell help page
- man command-name
  * displays same help in terminal
- browse https://fishshell.com/
- browse https://github.com/jbucaran/fish-shell-cookbook
- to get help on any fish command, man {command}
  * ex. man function; man if, man switch

Installing
- browse https://fishshell.com/
  and search for "Go Fish"
- for macOS there is an installer
  and can run "brew install fish"
- for Window, can only run in Cygwin

Making default shell
- chsh -s /usr/local/bin/fish

Uninstalling
- change default shell to something else like bash
- run these commands
  rm -Rf /usr/local/etc/fish /usr/local/share/fish ~/.config/fish
  rm /usr/local/share/man/man1/fish*.1
  cd /usr/local/bin
  rm -f fish fish_indent

Configuring
- can configure from shell, in a configuration file, and in the web UI
- configuration file
  * ~/.config/fish/config.fish
- web UI
  * to start, fish_config [starting-tab-name]
  * tabs include
    - colors
    - prompt
    - functions
    - variables
      * can only view values of current variables
      * is this only universal variables?
    - history
    - bindings
    - abbreviations
- 

Tools for fish (in alphabetical order)
- Fisherman - https://github.com/fisherman/fisherman
  * "The fish-shell plugin manager"
- Fundle - https://github.com/tuvistavie/fundle
  * "a minimalist package manager for fish inspired by Vundle"
- Oh My Fish - https://github.com/oh-my-fish/oh-my-fish
  * "provides core infrastructure to allow you to install packages
    which extend or modify the look of your shell"
- Tacklebox - https://github.com/justinmayer/tacklebox
  * "makes it easy to organize and share collections of
    useful shell functions, tools, and themes"

Colors
- all colors are customizable
- colors mentioned below are the defaults
- when entering commands,
  text is red until a valid command is entered
  and then it changes to white
- when typing file paths, the text is underlined
  unless no directory or file matches what has been typed

Autosuggestions
- suggests commands as you type
- suggested completion text is gray
- gets suggestions from command history,
  possible commands, possible options, and file paths
- to accept completion, press right arrow
  * still need to press enter to execute command
- continue typing if suggestion is not desired

Command History
- type part of a previous command and press up and down arrows
  to navigate through all previous commands that match
- press enter to execute one or ctrl-c to exit

Tab Completions
- can complete command names, options, file paths,
  and git branch names (including remote branches)
- while entering a command, press tab
- if there is only one option, it will be expanded in place
- if there is more than one option,
  up to four will be listed on separate lines
- to select an option, press tab repeatedly until
  the desired option is highlighted and press enter
  * highlighting cycles back to first option
    if tab is pressed while last option is highlighted
- to filter list of options,
  press tab until an option is highlighted,
  then type a substring that must be contained
- to skip selecting an option, press esc
- if there are more than four options, the first four will be listed
  followed by "...and n more rows"
- to see remaining options, press tab again
- try completing file paths for the cd command
  * press tab once to see options,
    again to show all options if more than four,
    and again to highlight first option

Aliases
- to define an alias
  * alias name "{command}"
  * defines a function with the specified name that runs the command
    - not actually written to files under ~/.config/fish/functions
  * only available in the current session, unlike abbreviations
    - so abbreviations are preferred
- to list all aliases
  * alias
- to undefine an alias
  * erase the function with: functions -e name

Abbreviations
- similar to aliases, but expand when typed
- available in all sessions, unlike aliases
- to define
  * abbr name value
- to list all abbreviations
  * abbr
- to undefine (erase) an alias
  * abbr -e name

Changing Working Directory
- can use cd command like other shells
- can also just enter a directory path
  * ex. ~ cds to home directory
  * can enter any path that starts with ., /, or ~
  * ex. .. cds to parent directory

Commands
- command arguments are just separated by spaces
- to include a space in an argument,
  preceded space with a backslash or
  enclose argument in single or double quotes
- to execute multiple commands on one line,
  separate with semicolons
- all commands set the "status" environment variable to
  0 for success and another number for failure
- to execute one command and then execute a second command
  only if the first is successful
  * command1; and command2
  * note the semicolon at end of first command
  * note the use of "and" instead of "&&" like in bash
- to execute one command and then execute a second command
  only if the first failed
  * command1; or command2
  * note the use of "or" instead of "||" like in bash
- NEED AN EXAMPLE OF USING "not"

Wildcards
- can use * like other shells
- can also use ** to traverse any number of directories

Pipes and Redirections
- pipe with | like other shells
- for commands that read from stdin,
  to read from a file instead use < like other shells
  ex. some-command < file-path
- for commands that write to stdout,
  to write to a file instead use > like other shells
  ex. some-command > file-path
- for commands that write to stderr,
  to write to a file instead use ^ unlike other shells that use 2>
  * ex. some-command ^ file-path
  * but can also use 2>
- to redirect stderr to stdout, some-command 2>&1

Variables
- set with: set {name} {value}
  * by default variables are local to the block where they are defined
    - can specify with -l (--local), but this is the default
  * to make them global to the session, add -g option (--global)
    - really visible to everything in the same process?
  * to export them so they are visible in child processes,
    add -x option (--export)
  * to make them universal so they are
    shared between all processes on the current computer
    and saved across restarts, add -U option (--universal)
  * already defined, the scope cannot be changed
    - erase it and then set again
- all variable values are lists that hold zero, one, or more string values
- How can you determine the scope of a given variable?
- variable names are case-sensitive
  * myvar and myVar are different variables
- delete (erase) with: set -e {name} (--erase)
- query (determine if set) with: set -q {name} (--query)
  * sets status variable to 0 if defined and 1 if not
    - to see, echo $status
  * to see value, echo ${name}
- list names and values of all variables: set
- list names of all defined variables: set -n (--names)
  * this may abbreviate long names
  * to avoid, use -L (--long)

Strings
- literals are delimited by single or double quotes
  * ex. set name 'Mark Volkmann'
- variable substitution occurs in double quotes, but not in single
  * ex. set msg "Good morning, $USER. Have a great day!"
- to get length
  * string length $name
- indexed starting at 1
- the "string" command has many "subcommands"
- to get a substring
  * string sub $name -s startIndex -l length
  * if -s is omitted, it defaults to 1
  * if -l is omitted, gets to end
  * if -s is negative, it counts from end
    - ex. to get last three characters, use -s -3
- to set a new variable to a substring
  * set newVar (string sub $name ...)
- to split a string on a delimiter, resulting in a list
  * string split delim $var
  * ex.
    set csv 'red,green,blue'
    set colors (string split , $csv)
- to concatenate a literal string with the value of a variable
  * ex.
    set middle 'some middle'
    set result 'some prefix'$middle'some suffix'
- to test whether a string ...
  * is empty: if test -z $var
  * is not empty: if test -n $var
  * is identical to another: if $v1 = $v2
  * is not identical to another: if $v1 != $v2

Numbers
- only integers are supported, not floating point
- to test the relationship between two numbers ...
  * equal: if $n1 -eq $n2
  * not equal:  if $n1 -ne $n2
  * less than:  if $n1 -lt $n2
  * less than or equal:  if $n1 -le $n2
  * greater than:  if $n1 -gt $n2
  * greater than or equal:  if $n1 -ge $n2
- both operands must be a number

Dates
- date command returns current date by default
- format using a format string defined by strftime
  * http://man7.org/linux/man-pages/man3/strftime.3.html
- ex. date "+%A %B %d, %G" # Tuesday, August 15, 2017

Files
- to test whether a file ...
  * exists: if test -e $file
  * is a file: if test -f $file
  * is a directory: if test -d $file
  * is a symbolic link: if test -L $file
  * is readable: if test -r $file
  * is writable: if test -w $file
  * is an executable file: if test -x $file
  * is a non-empty file (has size): if test -s $file
  * and more (see test command for details)

Tests
- commmonly used in "if" and "while" statements
- tests for strings, numbers, and files
  are described in those sections
- to negate any test, add "!" before "test"
- two ways to combine conditions with "and" or "or"
  * option 1: place each command on a separate line where
    each line but the first begins with "and" or "or"
    - ex.
      test $color = 'yellow'
      and test $size = 'large'
    - "and" cannot be placed at the end of the first line
  * option 2: place -a or -o between the conditions
    - ex. test \( $color = 'yellow' \) -a \( $size = 'large' \)
    - this is too ugly! prefer option 1

Command Substitution
- surround command with parens,
  not backticks like in some other shells
- to set a variable to the output of a command
  * set name (command)
  * ex. set today (date)
- can concatenate command output with literal strings
  and other command output
  * ex.
    set dateFormat '+%A %B %d, %G' # ex. Tuesday, August 15, 2017
    set announcement 'Today is '(date $dateFormat)'.'
    - note the use of string concatention by placing
      literal strings next to the parens
- doesn't work inside strings
  * ex. the command is not evaluated in
    "Today is (date $dateFormat)."

Eval
- evaluates a command in a string
  that can be built using concatention and variable substitution
- ex.
  set extension '.js'
  set command ls *.$extension
  eval $command

Lists
- lists cannot contain other lists
- to create an empty list
  * set myList
- to create a non-empty list
  * set myList item1 item2 ...
- to append
  * set myList $myList newItem
- to prepend
  * set myList newItem $myList
- to get an items by index
  * myList[index]
  * indexes start at 1, not 0
  * use negative indexes to retrieve from end
    - myList[-1] gets last item
- get a slice which is a new list
  * myList[start..end]
  * start and end can be positive or negative
- to test whether an item is in a list
  * if contains someItem $myList
      # code goes here
    end
  * contains sets status to 0 if found and 1 if not
- to remove an item
  * if set -l index (contains -i someItem $myList)
      set -e myList[$index]
    end
  * see .config/fish/functions/listrm.fish
    - TRY TO FIX ISSUE IN THIS!
- to get the length of a list
  * count $myList
- to iterate over all items in a list
  * for item in $myList
      # use $item here
    end
- adjacent lists
  * result in cartesian products
  * ex.
    set columns a b c
    set rows 1 2
    set cells $columns$rows # a1 b1 c1 a2 b2 c2
    count $cells # 6
    set labels "Column "$columns # Column a Column b Column c
    count $labels # 3
- conversion to lists
  * when a fish shell is started,
    if the variables PATH, CDPATH, or MANPATH exist,
    they are converted to lists by splitting on colons

Hashmaps
- not currently supported, but discussed here:
  https://github.com/fish-shell/fish-shell/issues/390
- can simulate with plain variables,
  but can't iterate over the keys unless they are held in a list
  ex. set colors red green blue
      set items-red fire
      set items-green grass
      set items-blue water
      for color in colors
        eval echo '$'items-$color
      end

PATH environment variable
- a universal variable that holds a list of paths
- to see current value
  * echo $PATH
  * paths are separated by spaces
- the environment variable fish_user_paths
  is automatically prepended to this
  * WHY?
- to prepend a path to PATH
  * set -U fish_user_paths $fish_user_paths {new-path}
  * outputs a warning if new-path doesn't exist but adds it anyway
  * see .config/fish/functions/addpath.fish
- to remove a path from PATH
  * if set -l index (contains -i {some-path} $fish_user_paths)
      set -e fish_user_paths[$index]
    end
  * sure this is a mess, but is it easier in bash?
  * see .config/fish/functions/rmpath.fish

Functions
- a fish function is a list of commmands
  that are executed when the name of the function
  is used as a command
- to define a function
  * function name
      # code goes here
    end
  * many options can follow the function name
    - some are described later
    - to add documentation, --description "some desc"
      * or -d
      * displayed when ???
- all functions are public
  * use prefixes for "private" functions
    to avoid name conflicts
    * ex. _prefix_name
- to make available in future sessions
  * define in files under .config/fish/functions
  * these files are loaded the first time
    the function they define is called
  * name of file must match name of function
    - the autoloading mechanism for functions requires this
    - ex. define function foo in file named foo.fish
  * can define multiple functions in the same file,
    but they will not be available until the function
    whose name matches the file is called once
    - so doing this is not recommended
- to save a function definition that has been entered interactively
  in a file in .config/fish/functions
  * funcsave myname
  * uses tabs for indentation
- to list all currently defined functions
  * functions
    - add --all or -a to include functions that begin with an underscore
  * to view in web UI
    - fish_config functions
- to output the code for a function
  * functions myname
- to copy a function definition to a new name
  * functions --copy old-name new-name
    - or -c
  * only copies body, not options
- to delete (erase) a function: functions -e name
  * doesn't remove automatically loaded functions
  * doesn't delete files that define them
  * just makes them inactive
- to see where a function is defined
  * functions --details name
    - or -D
  * if not saved to a file, will output "stdin"
- to test if a function exists
  * functions --query name
    - or -q
  * sets status
- functions can be use as command-line commands
  * after changes, may need to start a new shell
- to call a function, must specify its name
  * no parens around arguments or commas between them
- can use "return" to exit before end
- arguments
  * held in a list in $argv
    - first argument is in $argv[1]
  * iterate over arguments like iterating over any list
  * can also use named parameters
    - function orderShirt -a color size
        # Use $color and $size here.
        # $argv is also set to a list of the arguments.
      end
- options
  * to process command-line arguments as options
    for option in $argv
      switch "$option"
        case -h --help
          # code here
        ...
        case '*'
          # code here
      end
    end
- after modifying a function, do the changes
  only take effect after it has been called twice?
- functions can run automatically when an event is emitted
  * uses --on-event or -e option
  * see "Events" section
- functions can run automatically when a variable changes
  * uses --on-variable or -v option
  * ex.
    function announcePath --on-variable PATH
      echo PATH is now $PATH
    end
    set -U PATH /foo $PATH
- a function can run automatically when a given process exits
  * uses --on-process-exit or -p
  * ex.
    function announceProcessExit --on-process-exit 12345
      echo an important process exited
    end
- a function can run automatically when signal is received
  * uses --on-signal or -s followed by a signal name or number
  * see https://www.tutorialspoint.com/unix/unix-signals-traps.htm
  * to see a list of supported signals, enter "kill -l"
  * ctrl-c sends an "int" signal
  * to send any signal to a given process
    - kill -sig pid
      where sig is a signal name or number
  * ex. to handle a kill of the current process
    function handleTermSignal --on-signal term
      echo received term signal
    end
    TRY THIS!

Types of commands
- three types: builtins, commands, and functions
- builtins
  * provided by the shell
  * examples include: contains, echo, and if
  * to get a list of builtin names
    - builtin --names (or -n)
    - the "builtin" command can also be used to
      execute a specific builtin instead of a
      command or function with the same name
- commands
  * executables found in PATH
  * ex. chmod, ls, node, and vim
  * to get information about a command
    - command name
  * to get the path to a command
    - command --search name
      or
      which name
    - the "command" command can also be used to
      execute a specific command instead of a
      builtin or function with the same name
- functions
  * some are provided by fish
    ex. abbr, cd, eval
  * user-defined functions can be defined in .fish files
    under ~/.config/fish/functions
  * aliases are converted to functions
  * there are many fish-specific functions
    whose names begin with "fish_"
  * to determine if a function is defined
    - functions --query name
      * sets status to 0 if defined or 1 if not
- to get the type of a name
  * type name
  * for functions, this also outputs their definition

If statements
- if condition
    statements
  else if condition
    statements
  else
    statements
  end
- condition must be a command and its status is used
  * 0 is success and treated as true
  * any other value is an error and treated as false
  * opposite from most programming languages
- a common command to use in an "if" is "test"
- for a single line "if"
  * if condition; statement; end

Switch statements
- switch expression # ex. $color
  case value1 value2
    statements
  case value3
    statements
  case '*' # like default in other languages
    statements
  end
- each case can be followed by one or more values
  separated by spaces
- does not fall through, no break at end of each case

Loops
- see "Lists" section for iterating over items in a list
- YOU STOPPED HERE in https://fishshell.com/docs/current/tutorial.html

Multiple statements on same line
- separate by semicolons
- ex. function foo; echo in foo; end

Custom Prompt
- the default fish prompt displays whoami, hostname,
  the abbreviated working directory (returned by prompt_pwd),
  and ">"
- to customize, create ~/.config/fish/functions/fish_prompt.fish
- if custom prompt doesn't fit in terminal width,
  it will use just "> " instead
- ex.
function fish_prompt
  # Get the current Git branch.
  # This will be an empty string if not in a Git repo.
  set git_branch (git rev-parse --abbrev-ref HEAD ^/dev/null)

  # If in a Git repo (-q for quiet) ...
  if string length -q $git_branch
    set branch " ($git_branch)"
  else
    set branch ''
  end

  set_color --bold brblue
  echo -n $PWD # -n suppresses newline at end
  set_color --bold yellow
  echo $branch
  set_color normal
  echo -n '🐠  '
end

Reading from stdin
- read var
  * waits for user to enter something,
    terminated by enter key
  * sets var to what user entered
- options
  * --command text or -c text
    - sets initial text as if user had entered it
    - users can modify this
  * same options as "set" for choosing scope of variable
    - includes -l (local), -g (global), -x (export), and -U (universal)
  * --silent or -i to mask input (ex. for passwords)
  * --prompt-str text or -P text
    - sets prompt text
  * --prompt-cmd text or -p text
    - sets prompt command that outputs the prompt
    - useful for dynamic prompts
  * --array or -a
    - sets variable to a list of the words entered
  * and many more
- can have more than one variable
  * sets each to the word at the corresponding position
  * last variable gets all remaining workds
  * ex. read first second
    - if user enters "foo bar baz",
      first is set to "foo" and
      second is set to "bar baz"

Reading Files
- to iterate over lines in a file
  direct a file into a loop as follows:
  while read line
    # do something with the line
  end < file-path

Events
- functions can run automatically when an event is fired
  * uses --on-event or -e option
  * function takeShelter --on-event tornado
      echo Tornado warning! Take shelter!
    end
- can register any number of functions to run on the same event
- events can be emitted with: emit event-name
  * event-name can be followed by any number of arguments
  * these become the value of the argv list inside functions
  * ex. emit tornado 'category 4' 12
- events are only handled within the current process
- fish generates these events:
  * fish_prompt: whenever a new fish prompt is about to be displayed
  * fish_command_not_found: whenever a command lookup failed
    - like Ruby's method_missing
  * fish_preexec: before executing an interactive command
    - the command line is passed as the first parameter
    - emitted even if the command is invalid
  * fish_postexec: after executing an interactive command
    - the command line is passed as the first parameter
    - emitted even if the command is invalid

Document how to use the "spin" function you installed.
