Fish Shell Notes (version 2.6.0)

LOOK FOR TODO IN THIS FILE!

For article
- create example script in Fish, Bash, and Node
  that lists files containing given text in their name
  in tree form that colors file types differently
  (ex. red for .js, blue for .scss, ...)
  * maybe make colors configurable
- separate into these sections
  * basic usage
  * minor customizations
  * writing functions
  * advanced

Goals
- copied from https://fishshell.com/docs/current/design.html
  * Everything that can be done in other shell languages
    should be possible to do in fish,
    though fish may rely on external commands in doing so.
  * Fish should be user friendly, but not at the expense of expressiveness.
    Most tradeoffs between power and ease of use can be avoided
    with careful design.
  * Whenever possible without breaking the above goals,
    fish should follow the Posix syntax.
  * The shell language should have a small set of orthogonal features.
  * Everything should be tab-completable, and
    every tab completion should have a description.
  * Every syntax error and error in a builtin command should contain
    an error message describing what went wrong and a relevant help page.
    Whenever possible, errors should be flagged red by the syntax highlighter.
  * The language should be uniform, so that once
    the user understands the command/argument syntax,
    they will know the whole language, and be able to
    use tab-completion to discover new features.
  * see the webpage above for more

Licence
- uses GNU General Public License, version 2
  * summary:
    You may copy, distribute and modify the software
    as long as you track changes/dates in source files.
    Any modifications to or software including (via compiler)
    GPL-licensed code must also be made available under the GPL
    along with build and install instructions.

Help
- man command-name
  * displays same help in terminal
- help command-name or command-name -h
  * same as man, but displays browser which looks nicer
- browse https://fishshell.com/
  * entering just "help" opens the local copy of the documentation
    at this URL for the version of fish that is installed
    in the default web browser
- Github: https://github.com/fish-shell/
- use official mailing list at fish-users@lists.sourceforge.net
- use IRC channel #fish on irc.oftc.net

Installing
- browse https://fishshell.com/
  and search for "Go Fish"
- for macOS there is an installer
  and can run "brew install fish"
- for Window, can only run in Cygwin

Starting a fish shell
- enter "fish"
- to exit, enter "exit"

Making default shell
- chsh -s /usr/local/bin/fish

Uninstalling
- change default shell to something else like bash
- run these commands
  rm -Rf /usr/local/etc/fish /usr/local/share/fish ~/.config/fish
  rm /usr/local/share/man/man1/fish*.1
  cd /usr/local/bin
  rm -f fish fish_indent

Configuring
- can configure from shell, in a configuration file, and in the web UI
- configuration file
  * ~/.config/fish/config.fish
  * can define functions here, but it is
    more efficient to use autoloading functions
  * to run a command only when starting a login shell
    - determine from exit status of command "status --is-login"
      * ex. if status --is-login; ...; end
    - a login shell is created for every new terminal window
      * includes creating new tmux panes
  * to run a command only when starting an interactive shell
    - determine from exit status of command "status --is-interactive"
      * ex. if status --is-interactive; ...; end
    - an interactive shell is created when a subshell is created
      * ex. by entering "fish" inside a fish shell
    - login shells are also interactive
- web UI
  * to start, fish_config [starting-tab-name]
  * tabs include
    - colors
      * displays current color settings
        and allows them to be customized
    - prompt
      * displays current prompt
        and allows it to be customized
    - functions - view-only
    - variables - view-only
      * lists all universal variables and their values,
        not global or local variables
    - history - view-only
      * lists command history
    - bindings - view-only
      * lists current key bindings
    - abbreviations - view-only
      * lists abbreviations, typically defined in config.fish
  * TODO: Describe what can be done on each of these tabs.
  * pressing enter in the terminal will shutdown the server
    that serves this help
    - restarting it by entering fish_config again
      will open a new browser tab

Tools for fish (in alphabetical order)
- Fisherman - https://github.com/fisherman/fisherman
  * "The fish-shell plugin manager"
- Fundle - https://github.com/tuvistavie/fundle
  * "a minimalist package manager for fish inspired by Vundle"
- Oh My Fish - https://github.com/oh-my-fish/oh-my-fish
  * "provides core infrastructure to allow you to install packages
    which extend or modify the look of your shell"
- Tacklebox - https://github.com/justinmayer/tacklebox
  * "makes it easy to organize and share collections of
    useful shell functions, tools, and themes"

Colors
- all colors are customizable using the set_color command
- colors mentioned below are the defaults
- when entering commands,
  text is red until a valid command is entered
  and then it changes to white
- when typing file paths, the text is underlined
  unless no directory or file matches what has been typed
- specifying a color
  * color names
    - black, red, green, yellow, blue, magenta, cyan, white
    - brblack, brred, brgreen, bryellow, brblue, brmagenta, brcyan, brwhite
    - can list these with "set_color -c"
  * color values
    - 3 or 6 character hex
      * ex. f0f is full red, no green, and full blue which is purple
- set_color switches
  * --background (-b)
  * --print-colors (-c) prints list of named colors
  * --bold (-o) sets bold mode.
  * --dim (-d) sets dim mode
  * --italics (-i) sets italics mode
  * --reverse (-r) sets reverse mode
  * --underline (-u) sets underlined mode
  * using set_color without these switches resets to default mode
- variables that control colors
  * there are many that begin with "fish_color_"
    and "fish_pager_color_"
- ex.
  * echo Roses are (set_color red)red(set_color normal), \
      violets are (set_color blue)blue(set_color normal).
  * also see examples in your functions/fish_prompt.fish file

echo Command
- -n switch suppresses newline that is normally output at end
- -s switch causes arguments to not be separated by spaces

Autosuggestions
- suggests commands as you type
- suggested completion text is gray
- gets suggestions from command history,
  possible commands, possible switches (a.k.a. options),
  and file paths
- to accept completion, press right arrow
  * still need to press enter to execute command
- continue typing if suggestion is not desired

Command History
- all commands entered are saved in command history
  * unless they begin with a space (like incognito commands)
  * duplicate commands are removed, retaining only the most recent
- type part of a previous command and press up and down arrows
  to navigate through all previous commands that match
- press enter to execute one or ctrl-c to exit
- command history is stored in ~/.local/share/fish/fish_history
  * stores each command and when it was entered

Tab Completions
- can complete command names (all three kinds),
  switches,
  variable names
  (ex. echo $re then press tab to see all variables that contain "re"),
  file paths,
  git branch names (including remote branches),
  process names/ids
  (ex. kill fs and press tab to see all processes whose names contain "fs"),
  job names/ids,
  man page names
  (ex. man js and press tab to see all page names that contain "js"),
  ssh hosts,
  users (ex. su and press tab to see all usernames),
  and more
- while entering a command, press tab
- if there is only one option, it will be expanded in place
- if there is more than one option,
  up to four will be listed on separate lines
- to select an option, press tab repeatedly until
  the desired option is highlighted and press enter
  * highlighting cycles back to first option
    if tab is pressed while last option is highlighted
- to filter list of options,
  press tab until an option is highlighted,
  then type a substring that must be contained
- to skip selecting an option, press esc
- if there are more than four options, the first four will be listed
  followed by "...and n more rows"
- to see remaining options, press tab again
- try completing file paths for the cd command
  * press tab once to see options,
    again to show all options if more than four,
    and again to highlight first option

Custom Tab Completions
- can implement custom completions for custom commands
  * complete -c command-name -s short-switch -l long-switch -a 'argument words'
- an advanced topic
  * see your functions/greet.fish and completions/greet.fish example
    - TODO: not working!
  * see https://fishshell.com/docs/current/commands.html#complete
    and https://fishshell.com/docs/current/index.html#completion-own

Aliases
- to define an alias
  * alias name "{command}"
  * creates a function with the specified name that runs the command
    - not actually written to files under ~/.config/fish/functions
    - can also write a function to implement an alias,
      be see "Defining aliases" at
      https://fishshell.com/docs/current/index.html#introduction
      for important things to consider
      * these functions are not autoloaded,
        so they should either be defined in config.fish
        or sourced from there
  * only available in the current session, unlike abbreviations
    - so abbreviations are preferred
- to list all aliases
  * alias
- to undefine an alias
  * erase the function with: functions -e name

Abbreviations
- similar to aliases, but expand when typed
- available in all sessions, unlike aliases
- to define
  * abbr name value
- to list all abbreviations
  * abbr
- to undefine (erase) an alias
  * abbr -e name

Changing Working Directory
- can use cd command like other shells
- can also just enter a directory path
  * ex. ~ cds to home directory
  * can enter any path that starts with ., /, or ~
  * ex. .. cds to parent directory
- use tab completion to complete the next path part
  * can even press tab without typing anything
    to cd to a child directory
- dirh prints list of last 25 directories visited
  * current directory will be highlighted
  * to go back one, enter prevd or
    press cmd-option-left (alt-left in Windows)
  * to go forward one, enter nextd or
    press cmd-option-right (alt-right in Windows)

Commands
- every command is executed by entering its name
  followed by arguments, if any, separated by spaces
- commands are terminated by a newline or semicolon
  * of course in a shell, pressing enter produces a newline
  * semicolons allow multiple commands to appear on the same line
- multi-line commands
  * commands can split over multiple lines in two ways
    - by typing the \ continuation character and pressing enter
    - by pressing enter when there is an unterminated block
      started with begin, for, function, if, switch, or while
  * can be recalled and edited just like single-line commands
    - use up and down arrows to navigate between lines
- to include a space in an argument,
  preceded space with a backslash or
  enclose argument in single or double quotes
- arguments are expanded before commands are executed
  * this includes evaluating wildcards in file paths
- all commands set the "status" environment variable to
  0 for success and another number for failure
  * true and false are not boolean literals
  * false is a command that sets status to 1
  * true is a command that sets status to 0
- to execute one command and then execute a second command
  only if the first is successful
  * command1; and command2
  * note the semicolon at end of first command
  * note the use of "and" instead of "&&" like in bash
- to execute one command and then execute a second command
  only if the first failed
  * command1; or command2
  * note the use of "or" instead of "||" like in bash
- TODO: NEED AN EXAMPLE OF USING "not"
- autoloading
  * every time a command is evaluated
    it first checks whether there is a file
    in any path listed in fish_function_path
    with the same name and a .fish extension
    - this typically contains ~/.config/fish/functions
      which is where user-defined functions are usually placed
    - if found and the file has not been loaded
      within the "staleness interval",
      it loads the file to get the current definition of the function
      and executes the function
      * the staleness interval avoids thrashing the file system
      * around 5 seconds
    - does not search subdirectories of these paths
    - it is recommended that these files only define
      the function whose name matches the command
  * functions defined here
    - are immediately available in all fish shells
    - changes to them are automatically reloaded in all fish shells
      the next time they are used
  * this allows a function to be used in place of
    a command or builtin and executables in PATH
    - ex. function date; echo pwned date; end
      date outputs "pwned date" instead of the output of the date command
  * to run a command instead of a function with the same name
    - command name
  * to run a builtin instead of a function with the same name
    - builtin name

Wildcards
- ? matches a single character
- * matches any number of characters not containing /
- ** is like *, but also matches /
  which enables recursing into subdirectories

Pipes and Redirections
- pipe stdout of one command to the stdin of another
  with | like other shells
- for commands that read from stdin,
  to read from a file instead use < like other shells
  ex. some-command < file-path
- for commands that write to stdout,
  to write to a file instead use > like other shells
  ex. some-command > file-path
  * to avoid overwriting an existing file, use >?
  * to append, use >> instead of >
- for commands that write to stderr,
  to write to a file instead use ^ unlike other shells that use 2>
  * ex. some-command ^ file-path
  * but can also use 2>
  * to avoid overwriting an existing file, use ^?
  * to append, use ^^ instead of ^
- to redirect stderr to stdout, some-command 2>&1

Variables
- variable names consist of letters, digits, and underscores
- there are three variable scopes
  - local
    * available only in the current block
    * blocks begin with one of these keywords:
      begin, if, for, function, switch, or while
    * blocks end with the corresponding end keyword
  - global
    * available anywhere in the current session
  - universal
    * available in every session, even future sessions
      because they are saved across reboots
      - stored in ~/.config/fish/fishd.{machine-id}
- set with: set {name} {value}
  * to make it local, add --local (-l) switch
  * to make it global, add --global (-g) switch
  * to make it universal, add --universal (-U) switch
  * to export it so it is visible in child processes,
    add --export (-x) switch
    - this is not a new kind of scope
    - it is convention for exported variable names to be all uppercase
  * if set with no scope switch
    - if the variable has already been set in any scope,
      this changes the value of the lowest scope already set
    - if the variable has not already been set in any scope,
      the new variable will be local to the function in which it is set,
      not the block where it is set
      - if not in a function, it will be global
    - when a variable is set in config.fish with no scope switch,
      it defaults to global
- the same variable name can be set to different values in different scopes
  * references are resolved at the lowest scope found,
    local then global then universal
- get with $name
- can use multiple $'s to treat the value of a variable as a variable name
  * ex.
    set pocket 'wallet'
    set pant pocket
    echo $$pant # wallet
  * ex.
    set foreground blue
    set background green
    set side fore
    set name "$side"ground
    echo $$name # blue
- all variable values are lists that hold zero, one, or more string values
- variable names are case-sensitive
  * myvar and myVar are different variables
- delete (erase) with: set -e {name} (--erase)
  * will delete variable in the closest existing scope
    - local then global then universal
  * can specify the scope in which the variable should be erased
- to list names and values of variables
  * all: set
  * only universal: set -U
  * only global: set -g
  * only local: set -l
  * only exported: set -x
- to list only the names of all defined variables
  * set --names (-n)
  * add a scope switch to only list
    names of variables in a given scope
  * this may abbreviate long names
  * to avoid, add --long (-L)
- query (determine if set) with: set --query name (or -q)
  * sets status variable to 0 if set and 1 if not
    - to see, echo $status
    - ex. set -q color; echo $status
  * add a scope switch to only query in a given scope
    - ex. to query whether color is a global variable,
      set -qg color; echo $status
  * a variable can be set and not have a value
    - ex. set name
    - like setting a variable to null in JavaScript, versus undefined
  * to determine if a variable has a value
    - set -q name[0]

Special Variables
- there are many variables whose names begin with "fish_"
  that control various things
- examples
  * CMD_DURATION is set to the duration of the last command in milliseconds
  * COLUMNS is set to # of columns in current terminal
  * FISH_VERSION is set to the version of the fish shell being used
    - the "version" variable is also set to this
    - can also output by entering "fish -v"
  * HOME is set to the user's home directory
  * LINES is set to # of lines (or rows) in current terminal
  * PWD is set to the current (or present) working directory
  * USER is set to the current username
  * _ holds the name of the currently executing command
  * fish_user_paths - see "PATH" section
  * status is set to the status of the last command
- internal variables
  * variables whose names begin with __FISH or __fish
    are for internal use and should not be used or changed

status Command
- has many subcommands
- examples that are useful inside functions defined in .fish files
  * status current-filename
  * status current-function
  * status current-line-number
    - this has issues
    - see https://github.com/fish-shell/fish-shell/issues/4161
  * status print-stack-trace

Strings
- literals are delimited by single or double quotes
  * ex. set name 'Mark Volkmann'
  * in a single quoted string,
    single quotes can be escaped with \'
    and backslashes can be escaped with \\
  * in a double quoted string,
    double quotes can be escaped with \"
    $ which is used for variable substitution can be escaped with \$
    and backslashes can be escaped with \\
- variable substitution occurs in double quotes, but not in single
  * ex. set msg "Good morning, $USER. Have a great day!"
- to get length
  * string length $name
- indexed starting at 1
- the "string" command has many "subcommands"
- to get a substring
  * string sub $name -s startIndex -l length
  * if -s is omitted, it defaults to 1
  * if -l is omitted, gets to end
  * if -s is negative, it counts from end
    - ex. to get last three characters, use -s -3
- to set a new variable to a substring
  * set newVar (string sub $name ...)
- to split a string on a delimiter, resulting in a list
  * string split delim $var
  * ex.
    set csv 'red,green,blue'
    set colors (string split , $csv)
- to concatenate a literal string with the value of a variable
  * ex.
    set middle 'some middle'
    set result 'some prefix'$middle'some suffix'
    - these are similar but result in a list with count of 3
      set result some prefix"$middle"some suffix
      set result some prefix{$middle}some suffix
- to test whether a string ...
  * is empty: if test -z $var
  * is not empty: if test -n $var
  * is identical to another: if $v1 = $v2
  * is not identical to another: if $v1 != $v2

Numbers
- only integers are supported, not floating point,
  but they are stored in variables as strings
  * ex. set score 12345; echo (string length $score) # 5
- to test the relationship between two numbers ...
  * equal: if $n1 -eq $n2
  * not equal:  if $n1 -ne $n2
  * less than:  if $n1 -lt $n2
  * less than or equal:  if $n1 -le $n2
  * greater than:  if $n1 -gt $n2
  * greater than or equal:  if $n1 -ge $n2
- both operands must be a number

Dates
- date command returns current date by default
- format using a format string defined by strftime
  * http://man7.org/linux/man-pages/man3/strftime.3.html
- ex. date "+%A %B %d, %G" # Tuesday, August 15, 2017

Files
- to test whether a file ...
  * exists: if test -e $file
  * is a file: if test -f $file
  * is a directory: if test -d $file
  * is a symbolic link: if test -L $file
  * is readable: if test -r $file
  * is writable: if test -w $file
  * is an executable file: if test -x $file
  * is a non-empty file (has size): if test -s $file
  * and more (see test command for details)
- to iterate over lines in a file
  * direct a file into a loop as follows:
    while read line
      # do something with the line
    end < file-path


Tests
- commmonly used in "if" and "while" statements
- tests for strings, numbers, and files
  are described in those sections
- to negate any test, add "!" before "test"
- two ways to combine conditions with "and" or "or"
  * option 1: place each command on a separate line where
    each line but the first begins with "and" or "or"
    - ex.
      test $color = 'yellow'
      and test $size = 'large'
    - "and" cannot be placed at the end of the first line
  * option 2: place -a or -o between the conditions
    - ex. test \( $color = 'yellow' \) -a \( $size = 'large' \)
    - this is too ugly! prefer option 1

Command Substitution
- to use the output of one command as an argument to another,
  surround the command with parens,
  not backticks like in some other shells
- if the command outputs more than one line,
  each will be treated as a separate argument
  to the outer command
- to set a variable to the output of a command
  * set name (command)
  * ex. set today (date)
- can concatenate command output with literal strings
  and other command output
  * ex.
    set dateFormat '+%A %B %d, %G' # ex. Tuesday, August 15, 2017
    set announcement 'Today is '(date $dateFormat)'.'
    - note the use of string concatention by placing
      literal strings next to the parens
- doesn't work inside strings
  * ex. the command is not evaluated in
    "Today is (date $dateFormat)."

Brace expansion
- used to produce multiple arguments for a command
- ex. ls *.{css,html.js} expands to ls *.css *.html *.js
- also useful in the cp and mv commands

Eval
- evaluates a command in a string
  that can be built using concatention and variable substitution
- ex.
  set extension '.js'
  set command ls *.$extension
  eval $command

Lists (a.k.a. Arrays)
- lists cannot contain other lists
- to create an empty list
  * set myList
- to create a non-empty list
  * set myList item1 item2 ...
  * set colors red green blue
    is equivalent to
    set colors 'red' 'green' 'blue'
    which is not the same as
    set colors 'red green blue'
    in which the value of colors is a single string
- to append
  * set myList $myList newItem
- to prepend
  * set myList newItem $myList
- to get an item by index
  * myList[index]
  * indexes start at 1, not 0
  * use negative indexes to retrieve from end
    - myList[-1] gets last item
- to set an item by index
  * set myList[index] value
- to get a slice which is a new list
  * myList[start..end]
  * start and end can be positive or negative
- to test whether an item is in a list
  * if contains item $myList
      # code goes here
    end
  * this contains command sets status to 0 if found and 1 if not
- to get index of an item in a list
  * contains --index item $myList (-i)
- to remove an item
  * if set -l index (contains -i someItem $myList)
      set -e myList[$index]
    end
  * don't need if check if the item definitely exists
  * see .config/fish/functions/listrm.fish
    - TRY TO FIX ISSUE IN THIS!
- to create a reversed list
  * myList[-1..1]
- to get the length of a list
  * count $myList
- to iterate over all items in a list
  * for item in $myList
      # use $item here
    end
- adjacent lists
  * result in cartesian products
  * ex.
    set columns a b c
    set rows 1 2
    set cells $columns$rows # a1 b1 c1 a2 b2 c2
    count $cells # 6
    set dashedCells $columns'-'$rows # a-1 b-1 c-1 a-2 b-2 c-2
    set labels "Column "$columns # Column a Column b Column c
    count $labels # 3
    set cells {a,b,c}{1,2} # a1 b1 c1 a2 b2 c2
    - cannot have spaces around commas
- conversion to lists
  * when a fish shell is started,
    if the variables PATH, CDPATH, or MANPATH exist,
    they are converted to lists by splitting on colons

Hashmaps
- not currently supported, but discussed here:
  https://github.com/fish-shell/fish-shell/issues/390
- can simulate with plain variables,
  but can't iterate over the keys unless they are held in a list
  ex. set colors red green blue
      set items-red fire
      set items-green grass
      set items-blue water
      for color in colors
        eval echo '$'items-$color
      end

PATH environment variable
- a universal variable that holds a list of paths
  * not a colon-separated string
- to see current value
  * echo $PATH
  * paths are separated by spaces
- the universal variable fish_user_paths
  is automatically prepended to this
  * TODO: Why?
  * it is recommended to set fish_user_paths
    rather than modifying PATH
- to prepend a path to PATH
  * set -U fish_user_paths $fish_user_paths {new-path}
  * outputs a warning if new-path doesn't exist but adds it anyway
  * see .config/fish/functions/addpath.fish
- to remove a path from PATH
  * if set -l index (contains -i {some-path} $fish_user_paths)
      set -e fish_user_paths[$index]
    end
  * see .config/fish/functions/rmpath.fish
  * TODO: sure this is a mess, but is it easier in bash?
- before modifying fish_user_profile in config.fish,
  test that the value to be added isn't already present
  so each shell startup doesn't modify it again

Math
- the math function is a wrapper around the bc command
  (abbreviation for "basic calculator")
- supports floating point numbers
- converts strings to numbers
  * important because when a number is assigned
    to a variable, it is saved as a string
- pass a string containing a mathematical expression
- sets status to a non-zero number if expression is invalid
- writes result to stdout
- ex.
  set width 2
  set height 3
  set area (math "$width * $height") # 6
- some supported functions
  * sine: s(angle)
  * cosine: c(angle)
  * arctangent: a(angle)
  * natural logarithm: l(x)
  * e raised to a power: e(power)

Functions
- function names cannot begin with - and cannot contain /,
  but can contain any other characters, even spaces
  * to contain a space, prefix with \
    - ex. function foo\ bar; echo in foo bar; end
    - to call, foo\ bar
- a fish function is a list of commmands
  that are executed when the name of the function
  is used as a command in the shell
- to call a function, must specify its name
  * no parens around arguments or commas between them
- functions can be defined interactively
  by using the "function" command
  * this continues reading from stdin
    until it sees a line containing the closing "end"
- to define a function
  * function name
      # code goes here
    end
  * many switches can follow the function name
    - some are described later
    - to add documentation, --description "some desc"
      * or -d
      * displayed by "functions --details --verbose fn-name"
        in the fifth line
        - see --details below
      * see your fndesc.fish function that only displays the description
- all functions are public
  * use prefixes for "private" functions
    to avoid name conflicts
    * ex. _prefix_name
- to make available in future sessions
  * define in files under .config/fish/functions
  * no need to mark these files as executable
  * no need to modify PATH
    - all are defined in functions directory
      * can they be in subdirectories to categorize them?
  * no need to add a shebang comment
    - all are assumed to be used only in the fish shell
  * these files are loaded the first time
    the function they define is called
  * name of file must match name of function
    - the autoloading mechanism for functions requires this
      * see more in "Commands" section
    - ex. define function foo in file named foo.fish
  * can define multiple functions in the same file,
    but they will not be available until the function
    whose name matches the file is called once
    - so doing this is not recommended
- to save a function definition that has been entered interactively
  in a file in .config/fish/functions
  * funcsave name
  * uses tabs for indentation
- to edit a previously defined function
  * funced name
  * uses editor in variable VISUAL that can be set in config.fish
    - defaults to emacs
    - ex. set VISUAL vim
- to list all currently defined functions
  * functions
    - add --all or -a to include functions that begin with an underscore
  * to view in web UI
    - fish_config functions
- to output the code for a function
  * functions myname
- to see where a function is defined (its path)
  * functions --details name
    - or -D
  * if not saved to a file, will output "stdin"
- to see even more detail about a function
  * functions --details --verbose name
    - or -Dv
    - outputs these five lines
      * path to definition
      * whether it was autoloaded (outputs "autoloaded" or "n/a")
      * line number within file where definition begins
        or 0 if not autoloaded
      * whether "scope shadowing" was disabled
      * the function description specified with --description or -d
  * if not saved to a file, will output "stdin"
- to copy a function definition to a new name
  * functions --copy old-name new-name
    - or -c
  * only copies body, not switches
- to delete (erase) a function: functions -e name
  * doesn't remove automatically loaded functions
  * doesn't delete files that define them
  * just makes them inactive
- to test if a function exists
  * functions --query name
    - or -q
  * sets status
- return command
  - can use to exit before end
  * sets status of function which defaults to 0 for success,
    but can be specified
    - ex. return 2
- functions cannot return a value
  * they can only use the return command to return a status
  * but they can write to stdout
  * to set a variable to the stdout of a function
    - set var (fnname args)
    - ex.
      set width 2
      set height 3
      set area (math "$width * $height") # 6
- arguments
  * held in a list in $argv
    - first argument is in $argv[1]
  * iterate over arguments like iterating over any list
  * can also use named parameters
    - ex.
      function orderShirt -a color size
        # Use $color and $size here.
        # $argv is also set to a list of the arguments.
      end
    - all named parameters will be "set",
      but ones not specified will be set to an empty list
      * seems like a bad design
      * TODO: what's the rationale?
    - to test whether the named parameter is set,
      set -q name[1]
    - to set a named parameter to a default value,
      set -q name[1]; or set name 'default value'
- switches
  * to process command-line arguments as switches (a.k.a. options)
    for option in $argv
      switch "$option"
        case -h --help
          # code here
        ...
        case '*'
          # code here
      end
    end
- function do not have access to local variables set outside them
  * they are not closures

Auto-running Functions
- functions can run automatically when an event is fired
  * uses --on-event (-e) switch
  * ex.
    function takeShelter --on-event tornado
      echo Tornado warning! Take shelter!
    end
  * these functions are not auto-loaded
    - consider defining them in config.fish or
      sourcing files that define them from config.fish
      - source file-path
  * can register any number of functions to run on the same event
  * events can be emitted with: emit event-name
    - event-name can be any string
    - event-name can be followed by any number of arguments
    - these become the value of the argv list inside functions
    - ex. emit tornado 'category 4' 12
  * events are only handled within the current process
  * fish generates these events:
    - fish_prompt: whenever a new fish prompt is about to be displayed
    - fish_command_not_found: whenever a command lookup failed
      * like Ruby's method_missing
    - fish_preexec: before executing an interactive command
      * the command line is passed as the first parameter
      * emitted even if the command is invalid
    - fish_postexec: after executing an interactive command
      * the command line is passed as the first parameter
      * emitted even if the command is invalid
- functions can run automatically when a variable changes
  * uses --on-variable (-v) switch
  * ex.
    function announcePath --on-variable PATH
      echo PATH is now $PATH
    end
    set -U PATH /foo $PATH
- a function can run automatically when a given process exits
  * uses --on-process-exit or -p
  * ex.
    function announceProcessExit --on-process-exit 12345
      echo an important process exited
    end
    function announceMyExit --on-process-exit %self
      echo I am exiting
    end
- a function can run automatically when signal is received
  * uses --on-signal or -s followed by a signal name or number
  * see https://www.tutorialspoint.com/unix/unix-signals-traps.htm
  * to see a list of supported signals, enter "kill -l"
  * ctrl-c sends an "int" signal
  * to send any signal to a given process
    - kill -sig pid
      where sig is a signal name or number
  * ex. to handle a kill of the current process
    function handleTermSignal --on-signal term
      echo received term signal
    end
    TODO: TRY THIS!

Types of commands
- a command is any program the shell can run
- there are three types of commands: builtins, commands, and functions
- builtins
  * commands that are provided by the shell
  * examples include: contains, echo, and if
  * to get a list of builtin names
    - builtin --names (or -n)
    - the "builtin" command can also be used to
      execute a specific builtin instead of a
      command or function with the same name
- commands
  * executables found in PATH
  * ex. chmod, ls, node, and vim
  * to get information about a command
    - command name
  * to get the path to a command
    - command --search name (-s name)
      or
      which name
    - the "command" command can also be used to
      execute a specific command instead of a
      builtin or function with the same name
- functions
  * some are provided by fish
    ex. abbr, cd, eval
  * user-defined functions can be defined in .fish files
    under ~/.config/fish/functions
  * aliases are converted to functions
  * there are many fish-specific functions
    whose names begin with "fish_"
  * to determine if a function is defined
    - functions --query name
      * sets status to 0 if defined or 1 if not
- to get the type of a name
  * type name
  * for functions, this also outputs their definition

If statements
- if condition
    statements
  else if condition
    statements
  else
    statements
  end
- condition must be a command and its status is used
  * 0 is success and treated as true
  * any other value is an error and treated as false
  * opposite from most programming languages
- a common command to use in an "if" is "test"
- for a single line "if"
  * if condition; statement; end

and/or
- to conditionally execute a command only if another succeeded
  command1; and command2
- to conditionally execute a command only if another failed
  command1; or command2
- these can be used in the condition of an "if" or "while"

Switch statements
- switch expression # ex. $color
  case value1 value2
    statements
  case value3
    statements
  case '*' # like default in other languages
    statements
  end
- expression should evaluate to a string
- each case can be followed by one or more values
  separated by spaces
  * values that do not contain special characters
    do not need to be in quotes
- does not fall through; no break at end of each case
- to treat one case value as the default
  case default-value '*'

Loops
- while condition
    # commands go here
  end
  * condition can use "and" and "or"
  * uses status of condition to determine whether to iterate again
    0 to continue; anything else to stop
  * for an endless loop, use "true" for condition
- for var in list
    # use var here
  end
  * to iterate over a list of numbers, use seq command
    - ex. for n in (seq 5); echo $n; end
      * outputs 1, 2, 3, 4, 5 on separate lines
    - seq can be followed by 1, 2 or 3 numbers
      to specify the first, increment, and last values
      * if only one, it is the last, first defaults to 1, and incr defaults 1
      * if only two, they are first and last, and incr defaults to 1
  * can iterate over relative file paths that match a pattern
    ex. for path in b*.fish; echo $path; end
- in both kinds of loops
  * use "break" to exit early
  * use "continue" to skip remainder of current iteration

Multiple statements on same line
- separate by semicolons
- ex. function foo; echo in foo; end

Custom Greeting
- by default, new fish shells display the greeting
  "Welcome to fish, the friendly interactive shell"
- to change this,
  set -U fish_greeting 'You are a fish!'
- to suppress this, erase the current setting with
  set -e fish_greeting

Custom Prompt
- the default fish prompt displays whoami, hostname,
  the abbreviated working directory (returned by prompt_pwd),
  and ">"
- to customize, create ~/.config/fish/functions/fish_prompt.fish
  that echos the desired prompt
  * use set_color to control colors of various parts
  * can have multiple lines
- if custom prompt doesn't fit in terminal width,
  it will use just "> " instead
- ex.
function fish_prompt
  # Get the current Git branch.
  # This will be an empty string if not in a Git repo.
  set git_branch (git rev-parse --abbrev-ref HEAD ^/dev/null)

  # If in a Git repo (-q for quiet) ...
  if string length -q $git_branch
    set branch " ($git_branch)"
  else
    set branch ''
  end

  set_color --bold brblue
  echo -n $PWD # -n suppresses newline at end
  set_color --bold yellow
  echo $branch
  set_color normal
  echo -n '🐠  '
end
- can define a right prompt with the function fish_right_prompt
- can display Vim mode in prompt with the function fish_mode_prompt
  * ex. N for normal, I for insert, R for replace, and V for visuaul
  * see your functions/fish_mode_prompt.fish file
  * outputs a new prompt every time mode changes
    which is a bit distracting
    - make this an empty function to disable

Reading from stdin
- read var
  * waits for user to enter something,
    terminated by enter key
  * sets var to what user entered
- switches
  * --command text or -c text
    - sets initial text as if user had entered it
    - users can modify this
  * same switches as "set" for choosing scope of variable
    - includes -l (local), -g (global), -x (export), and -U (universal)
  * --silent or -i to mask input (ex. for passwords)
  * --prompt-str text or -P text
    - sets prompt text
  * --prompt-cmd text or -p text
    - sets prompt command that outputs the prompt
    - useful for dynamic prompts
  * --array or -a
    - sets variable to a list of the words entered
  * and many more
- can have more than one variable
  * sets each to the word at the corresponding position
  * last variable gets all remaining workds
  * ex. read first second
    - if user enters "foo bar baz",
      first is set to "foo" and
      second is set to "bar baz"

Processes
- to get the current process id, %self
- to get the process id of the job with number n, %n
- to get the ids of all processes whose names begin with "prefix", $prefix

Jobs
- to run a command in background, add & to end of command
  * does not work for custom functions!
  * TODO: Why?
- to suspend currently running command, press ctrl-z
  * does not work for custom functions!
  * TODO: Why?
- to continue running a suspended command in background enter "bg"
- to get a list of background jobs and their job numbers, enter "jobs"
- to bring a background job back to the foreground,
  enter "fg" for the job most recently placed in background
  or "fg %job-number" for a specific job
  or "fg process-number"
- if you try to exit from a shell that has background jobs,
  it will warn about this and not exit
  * if you try to exit again,
    it will kill all the background jobs and exit

Debugging Functions
- add use of "breakpoint" commands in function
- run the function
- when a breakpoint is reached,
  the function will stop and control will be returned to the shell
- can examine and modify variables in the function
  * ex. echo $count
  * ex. set count 7
- to resume execution, enter "exit"
- to stop the running function before it reaches its end,
  enter "kill %self"

TODO: Document how to use the "spin" function you installed.
