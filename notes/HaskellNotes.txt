Haskell Notes

Overview
- started in 1987 and standardized in 1999
- a purely functional language
- everything is immutable
  * can't change the value of variables
- statically typed with type inference
- lazy
  * doesn't evaluate function calls until the result is needed
- has no for or while loops
- the Vim ALE plugin has support for linting Haskell code!

Learning Resources
- free online book "Learn You a Haskell for Great Good!"
  at http://learnyouahaskell.com/
- https://www.haskell.org/
- https://wiki.haskell.org/

Installing
- browse http://hackage.haskell.org/platform/
- two options for Mac
  * download .dmg file and double-click
  * brew cask install haskell-platform

Compiler
- most popular is Glasgow Haskell Compiler (GHC)

Libraries
- browse http://hackage.haskell.org/

Interactive sessions
- enter "ghci" to start the REPL
- to exit, press ctrl-d
- recall previous commands with up arrow
- prompt
  * default is "Prelude> "
    - this is the name of the standard library that is automatically loaded
  * change with :set prompt "new prompt"
  * can add this command to ~/.ghci to change for all future sessions
  * mine uses an elephant emoji for the elephant on the
    cover of the book "Learn You a Haskell for Great Good!"
- to enable Vim keybindings
  * create ~/.haskeline and add "editMode: Vi"
- to see the type of a name, enter :t name
  * very useful for learning

Source Files
- referred to as Haskell scripts
- have a file extension of .hs
- load these into an interactive session with :l {filename}
  * can omit .hs extension when loading
- reload current script with :r
- example
  * create file hello.hs containing this function definition:
    hello name = "Hello, " ++ name + "!"
  * ghci
  * :l hello
  * hello "Mark"

Comments
- single-line: start with --
- multi-line: surround with {- -}

Operators
- these are actually infix functions
- numbers
  * basic: + - * /
  * exponentiation: **
    - ex. 2 ** 3 == 8
  * use parens to control order of evaluation
  * div performs integer division, discarding the remainder
    - ex. div 8 3 == 2
  * mod a b retunns a modulo b
  * gcd a b returns the greatest common denominator of a and b
    - ex. gcd 12 15 == 3
  * lcm a b returns the lowest common multiple of a and b
    - ex. lcm 6 10 == 30
  * even n determines if n is even
  * odd n determines if n is odd
- logic
  && for and
  || for or
  not (the word rather than ! as in some other languages)
- comparison
  * operands must be the same type
  * == for equal
  * /= for not equal
  * < <= >= >

Boolean
- Bool - values are True and False

Numbers
- primitive types
  * Int - 4 bytes
  * Integer - arbitrary precison
  * Float - 4 bytes
  * Double - 8 bytes
  * surround negative numbers with parens
    to avoid confusion with the subtraction operator
    - ex. 5 + (-2)
- number typeclass hierarchy
  * note that a typeclass can derive from multiple other typeclasses
  * Num
    * Fractional
      * Floating
        * Float
        * Double
      * RealFrac
        * Float
        * Double
    * Real derives from Ord which adds ordering functions
      * Integral derives from Enum
        * Int
        * Integer
      * RealFrac
        * Float
        * Double
  * RealFloat derives from RealFrac and Floating
    * Float
    * Double
  * Complex
- type conversions
  * to convert an Integral to a Floating, fromIntegral integralValue

Characters
- Char - single letter surrounded by single quotes

Strings
- literal values are surrounded by double quotes
- really a list of characters
- concatenate with ++
  * really builds a new list from two lists

Names
- variable identifiers start with a lowercase letter
- constructor identifiers with an uppercase letter
- both can contain underscores, single quotes, letters and digits
- operators are formed from one or more of '!#$%&*+./<=>?@\^|-~'
- constructors can be operator names, if they start with a ':'
  - ex. :+ for Data.Complex

Modules
- module names must start with an uppercase letter
- can use functions in any module by prefixing them with the module name
  * ex. Data.List, Data.Map, System.IO
- to use functions in a module without prefixes, import ModuleName
- the most commonly used functions are defined in the Prelude module
  which is imported by default
- to define a module
  * create a file named {module-name}.hs
  * first line must be
    module {module-name} where
  * add definitions after this

Functions
- syntax to call
  * name arguments
  * arguments are separated by spaces
  * to use the result of another function as an argument
    surround the call with parens
    - ex. max (min 2 3) (min 5 4) == 4
- syntax to define
  * name parameters = expression
  * parameters are separated by spaces
  * if the name consists of letters, the function is prefix
    - if the function has two parameters,
      surround with backticks to use as infix
    - ex. 8 `div` 3 == 2
  * if the name consists of symbols, the function is infix
    - if the function has two parameters,
      surround with parens to use as prefix
    - ex. (*) 2 3 == 6
- defaults to prefix
  - can you specify that a function is infix?
- name cannot begin with an uppercase letter
- most functions are prefix functions,
  but some are infix functions
- to call a prefix function,
  start with the name followed by arguments
  all separated by spaces (no parens)
- all functions return a value
- prefix functions are evaluated before infix functions,
  so parens are needed in succ (2 * 3) which returns 7
  * succ 2 * 3 returns 9
- builtin functions
  * for numbers
    - div returns integer division result
    - max returns largest of two arguments
    - min returns smallest of two arguments
    - pred n returns n - 1
    - succ n returns n + 1
    - round (closest), ceiling (up), floor (down), truncate (toward zero)
    - sqrt n returns square root of n
    - trigonometry: sin, cos, tan, asin, acos, atan,
    - hyperbolic: sinh, cosh, tanh, asinh, acosh, atanh
    - logarithmic: log, exp (e ** n)
- builtin variables
  * for numbers
    - pi
- example
  hypot x y = sqrt (x * x + y * y)
  hypot 3 4 returns 5
- scripts can call functions defined later in the file

Types
- ues Hindley-Milner type system
- syntax is name :: type
- variable example
  * firstName :: String
- function example
  * add :: Num a => a -> a -> a
    add x y = x + y
  * means all occurrences of a in the signature have type Num
  * takes two Num arguments and returns a Num
  * ghci detail
    - entering the type signature and definition on two lines doesn't work
    - workarounds
      * enter them on same line separated by a semicolon
        - ex. let add :: Num a => a -> a -> a; add x y = x + y
      * enter them in a block
        :{
        let add :: Num a => a -> a -> a
            add x y = x + y -- indented 4 spaces
        :}
      * turn on multline mode which automatically infers use of :{ and :}
        :set +m -- one tie
        let add :: Num a => a -> a -> a
            add x y = x + y -- indented 4 spaces
        press return to exit block
  * automatically supports currying
    - ex.
      plus5 = add 5
      plus5 2 == 7
- another function example
  * charAt :: String -> Int -> Char
    charAt str index = str !! index
- type classes
  * define an interface that specific types implement
  * builtin examples include Eq, Ord, Show, Read,
    Enum, Bounded, Num, Floating, and Integral

Lists
- all items must be the same type
- items are surrounded by square brackets
  and separated by commas
- ex. [1, 3, 7]
  * same as 1 : 3 : 7 : []
  * : is called the "cons" operator
- implemented as linked lists, so
  accessing items other than the first is not efficient
- to get number of items, length list
- to test whether a list is empty, null list
  * returns a boolean
- slicing
  * these raise an exception if called on an empty list
  * to get first item, head list
  * to get last item, last list
  * to get all but first item, tail list
  * to get all but last item, init list
- to create a list that contains the first n items, take n list
- to create a list that contains the last n items, drop n list
- to create list that is result of prepending new item
  * item : list
- to create list that is result of appending new item
  * list ++ [item]
- to create list where first item is modified
  * newItem : tail list
- to create a new list by concatenating two lists
  * list1 ++ list2
  * both arguments must be a list
- to get an item at a given index
  * list !! index
  * indexes start at 1
  * also used to get a character from a string since those are lists
  * slow for long lists since implemented with a linked list
- to create a reversed copy of a list: reverse list
- to get smallest number in a list: minimum list
- to get largest number in a list: maximum list
- to get sum of numbers in a list: sum list
- to get product of numbers in a list: product list
- to test whether an item is in a list: elem item list
- lists can be nested
- lists can be compared if corresponding items can be compared
  * ex. [1, 3, 5] < [2, 4, 6] gives True
  * ex. [1, 3, 5] < [1, 4, 6] gives True
  * ex. [1, 3, 5] < [1, 3, 6] gives True
  * ex. [1, 3, 5] < [1, 3, 5] gives False
- other list functions
  * notElem
  * concat takes a list of list and returns a flatten list
    - the lists cannot contain nested lists
      * recall that all items in a list must be the same type,
        so [1, [2, 3]] is not a valid list
    - ex. concat [[1,2], [3,4,5]] == [1,2,3,4,5]
  * takeWhile creates a list of all initial items
    in another list that meet a predicate
    - ex. takeWhile even [2,4,6,7,8] == [2,4,6]
  * dropWhile creates a list of all remaining items
    in another list after the initial elements meet a predicat
    - ex. dropWhile even [2,4,6,7,8] == [7,8]
  * words takes a string and returns a list of words delimited by spaces
    - ex. words "foo bar baz" == ["foo","bar","baz"]
  * unwords takes a list of works and returns a string of the words separated by spaces
    - ex. unwords ["foo","bar","baz"] == "foo bar baz"
  * splitAt creates a list of two lists obtained by
    spliting a given list at an index
    - ex. splitAt 3 [1,2,3,4,5] == [[1,2,3], [4,5]]
  * sort creates a sorted version of a list
    - must import Data.List
    - ex. sort [9, 3, 6, 2] == [2, 3, 6, 9]
  * zipWith creates a list from multiple lists using the result
    of a function called with items at corresponding positions
    - ex. zipWith min [1, 9, 5, 4] [2, 7, 6] === [1, 7, 5, 4]
    - note how the last item in the first list has no corresponding item
      in the second, so it just used that item in the result

Ranges
- create lists of all elements between two items inclusive
  * ex. [3..7] == [3,4,5,6,7]
  * ex. ['c'..'f'] == "cdef"
- can specify a step by including second item
  * ex. [5, 10..27] == [5,10,15,20,25]
- specifying a step is the only way to get a decreasing range
  * ex. [10, 9..0] == [10,9,8,7,6,5,4,3,2,1,0]
- to create an infinite list, don't specify upper bound
  * ex. [3, 6..]
  * in the REPL this will output items forever (ctrl-c to stop)
  * use a function like take to limit the output
    - ex. take 10 [3, 6..]
- replicate creates a list containing a given number of the same item
  * ex. replicate 3 "Ho" == ["Ho","Ho","Ho"]
  - note how this creates a list of strings rather than an single string
- repeat creates an infinite list of a single repeated item
  * ex. take 4 (repeat 3) === [3,3,3,3]
- cycle creates an infinite list of repeating items
  * ex. take 6 (cycle [5, 10]) === [5,10,5,10,5,10]

List Comprehensions
- like a list factory
- produces a list containing the results of an expression
  where a variable is set to each value in another list
- ex. [n * 2 | n <- [1..4]] == [2,4,6,8]
  * n * 2 is called the "output"
  * [1..4] is the list from which values are "drawn"
  * each item drawn is bound to n
- a "predicate" can be added after the draw list
  to filter the items drawn
  * ex. [n * 2 | n <- [1..4], even n] == [4,8]
  * can have any number of predicates separated by commas
- can draw values from more than one list
  * ex. [a + b | a <- [1,2,3], b <- [4,5]] == [5,6,6,7,7,8]
  * uses the cartesian product of the lists
  * goes through all items in second list for each item in first list
    - order is 1 and 4, 1 and 5, 2 and 4, 2 and 5, 3 and 4, 3 and 5
  * can split onto multiple lines, but not in the REPL
    - ex.
      [n * 2 |
       n <- [1..4],
       even n]
- ex. remove all spaces, dashes, and underscores from a string
  * squeeze str = [char | char <- str, not (elem char [' ', '-', '_'])]
  * squeeze "foo bar-baz_qux" == "foobarbazqux"

Tuples
- a fixed length set of values with specific types at each position
  * each position can hold a different type
  * called a "pair" if two items (most common size)
  * called a "triple" if three items
- items are surrounded by parens instead of
  square brackets that are used for lists
- fst t returns the first item in the two-item tuple t
  * only works for tuples with a length of 2
- snd t returns the second item in the two-item tuple t
  * only works for tuples with a length of 2
- zip creates a list of tuples from two lists
  * ex. zip [1, 2, 3] [4, 5] === [(1,4), (2, 5)]
  * number of tuples in result is equal to length of shortest list
- unzip creates a tuple of lists from a list of tuples
  * ex. unzip [(1,4), (2,5)] == ([1,2], [4,5])

Association Lists
- a list of tuples where each tuple is a key/value pair
- there is also a Map type defined in Data.Map
- ex. mapping = [("foo", 1), ("bar", 2)]
- lookup function finds the value for a given key
  * ex. lookup "bar" mapping == Just 2
  * ex. lookup "baz" mapping == Nothing
  * just does a sequential search, so not efficient

Data.Map
- a hashmap data structure
- can create from an association list
- to use, without Data.Map prefix, import Data.Map
- ex. myMap = fromList [("foo", 1), ("bar", 2)]
- to get the value for a given key, myMap ! key
- to get the number of keys in a Map, size myMap

Conditional Logic
- if expression
  * if condition then expression else expression
  * else is required
  * no parens or semicolons
  * returns value of selected expression

Higher Order Functions
- these are functions that take an argument that is a function
- map returns a list contructed from the results
  of passing each item in a list to a function
  * ex. map succ [1,3,7] == [2,4,8]
- filter
  * takes a function and list and returns a list of
    the items for which the function returns True
  * ex. filter odd [1,4,7,10] == [1,7]
  * ex. filter (> 5) [1,4,7,10] == [7, 10]
    - (> 5) creates a function using currying
- foldl is like reduce in JavaScript
  * takes a function, starting value, and a list
    - if the function is an infix function,
      surround it with parens to turn it into a prefix function
  * ex. foldl (*) 1 [1,2,3,4] == 24
    - of course this can be done more easily with product [1,2,3,4]
- foldr is like foldl, but processes
  the list items from right to left

Other Functions
- show thing
  returns the string representation of thing
  * requires thing to have a Show function
- read str :: type
  returns result of converting str to an instance of type

Variables
- to set use name = expression
- does this really create a function that
  always returns the value of the expression?

Libraries
- array
- base
- binary
- bytestring
- Cabal
- containers
- deepseq
- directory
- filepath
- ghc
- ghc-boot
- ghc-compact
- ghc-prim
- hoopl
- hpc
- integer-gmp
- process
- template-haskell
- time
- unix
- Win32

PureScript
- compiles Haskell to JavaScript
