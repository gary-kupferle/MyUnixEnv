<!DOCTYPE html>)
<html>
  <head>
    <title>The fish Shell</title>
    <style>
      body {
        font-family: sans-serif;
      }
      code {
        background-color: lightyellow;
        font-weight: bold;
        padding: 3px 2px;
      }
      div {
        margin-bottom: 10px;
      }
      h1, h3 {
        color: blue;
      }
      h2 {
        border-top: solid red 3px;
        color: purple;
        padding-top: 20px;
        text-decoration: underline;
      }
      h4 {
        color: purple;
      }
      img {
        width: 800px;
      }
      pre {
        background-color: lightyellow;
        font-weight: bold;
        width: 800px;
      }
    </style>
  </head>
  <body>
    <h1>The fish Shell</h1>
    <div>
      by Mark Volkmann<br>
      mark@objectcomputing.com<br>
      Object Computing, Inc.<br>
      September 2017
    </div>
    <h4>
      Come for the colors and autocomplete,
      stay for the sane scripting!
    </h4>
    <img src="fish-logo.png" alt="fish logo">

    <h3>Overview</h3>
    <div>
      Fish is a *nix shell that offers an alternative
      to shells like bash and zsh.
      At a high level, fish provides the following benefits:
    </div>
    <ul>
      <li>auto-suggestions while typing</li>
      <li>auto-complete of commands, their switches, file paths,
        variable names, git branches, and more</li>
      <li>easy access to web-based help</li>
      <li>colorful prompts</li>
      <li>ability to customize colors and the prompt using a web UI</li>
      <li>highly consistent and simple scripting language</li>
    </ul>
    <div>
      This article explains why you might prefer fish over other shells.
      Really learning a shell is similar to learning a new programming language.
      Similar topics are covered here such as
      variables, functions, string operations, and so on.
    </div>
    <div>
      The latest version of fish at the time of this article is 2.6.0.
    </div>

    <h3>License</h3>
    <div>
      The fish shell uses the GNU General Public License, version 2.
      Here's a summary of that license:
    </div>
    <blockquote>
      You may copy, distribute and modify the software
      as long as you track changes/dates in source files.
      Any modifications to or software including (via compiler)
      GPL-licensed code must also be made available under the GPL
      along with build and install instructions.
    </blockquote>

    <h3>Goals</h3>
    <div>
      The goals for fish are listed at
      <a href="https://fishshell.com/docs/current/design.html">
        https://fishshell.com/docs/current/design.html
      </a>.
      Here are the most significant goals:
    </div>
    <ul>
      <li>
        Everything that can be done in other shell languages
        should be possible to do in fish,
        though fish may rely on external commands in doing so.
     </li>
      <li>
        Fish should be user friendly, but not at the expense of expressiveness.
        Most tradeoffs between power and ease of use
        can be avoided with careful design.
     </li>
      <li>
        Whenever possible without breaking the above goals,
        fish should follow the Posix syntax.<br>
        (This may lead some to avoid using fish for
        sysadmin and install types of scripts
        because there is often a desire for those to be highly portable
        without requiring installation of new software such as fish.
        However, for scripts targeted at typical users
        or scripts that only you will use,
        implementing them in a shell that is not 100% Posix compliant
        is much less of a concern.)
     </li>
      <li>
        The shell language should have a small set of orthogonal features.
      </li>
      <li>
        Everything should be tab-completable, and
        every tab completion should have a description.
     </li>
      <li>
        Every syntax error and error in a builtin command should contain
        an error message describing what went wrong and a relevant help page.
        Whenever possible, errors should be flagged red
        by the syntax highlighter.
      </li>
      <li>
        The language should be uniform, so that once
        the user understands the command/argument syntax,
        they will know the whole language, and be able to
        use tab-completion to discover new features.
      </li>
    </ul>

    <h3>History</h3>
    <div>
      The first release of fish was on Februrary 13, 2005.
      Axel Liljencrantz was the main developer and maintainer of
      versions 1.0 to 1.23.1 which were in SourceForge.
      The last 1.x release was in March 2009.
      Various people maintained forks at Gitorious and elsewhere,
      but it seems no releases were ever made.
      A person that goes by "ridiculousfish" got involved in about 2012
      and released a beta of a fork called fishfish.
      This brought in a lot of the work of previous fish contributors
      and eventually became fish 2.0.
    </div>
    <div>
      fish was originally implemented in C, but is now primarily C++.
    </div>
    <div>
      fish 3.0 is targeted to be released in Q1 2018.
      For a list of fixes/features targeted for this release, see
      <a href="https://github.com/fish-shell/fish-shell/milestone/18">https://github.com/fish-shell/fish-shell/milestone/18</a>.
      For a list of additional fixes/features that *may* be in this release, see
      <a href="https://github.com/fish-shell/fish-shell/milestone/7">https://github.com/fish-shell/fish-shell/milestone/7</a>.
    </div>

    <h3>Sections</h3>
    <div>
      The remainder of this article is split into three sections.
      The first section describes using fish.
      The second section describes customizing fish.
      The third section describes scripting in fish.
    </div>

    <h2>Using Fish</h2>

    <h3>Installing Fish</h3>
    <div>
      Instructions for installing fish are at
      <a href="https://fishshell.com/">https://fishshell.com/</a>.
      Search that page for "Go Fish".
    </div>
    <div>
      For macOS there is an installer.
      If <a href="https://brew.sh/">Homebrew</a> has been installed,
      fish can also be installed by entering <code>brew install fish</code>.
    </div>
    <div>
      For Windows, fish can be run in Cygwin.
      In Windows 10 fish can be run in the "Windows Subsystem for Linux" (WSL).
    </div>
    <div>
      In case you find fish is not for you,
      which I believe is highly unlikely, it can be uninstalled by
      changing the default shell to something else (like bash)
      and running the following commands:
    </div>
    <ul>
      <li><code>rm -Rf /usr/local/etc/fish /usr/local/share/fish ~/.config/fish</code></li>
      <li><code>rm /usr/local/share/man/man1/fish*.1</code></li>
      <li><code>cd /usr/local/bin</code></li>
      <li><code>rm -f fish fish_indent</code></li>
    </ul>

    <h3>Help</h3>
    <div>
      There are many sources for help on fish.
      The main web site at
      <a href="https://fishshell.com/">https://fishshell.com/</a>
      provides excellent documentation.
      Entering just <code>help</code> in a terminal
      opens the local copy of this documentation
      for the version of fish that is installed
      in the default web browser.
    </div>
    <div>
      Entering <code>man <i>command-name</i></code>
      displays help in the terminal.
      For many commands, entering <code><i>command-name</i> -h</code>
      is the same.
    </div>
    <div>
      Entering <code>help <i>command-name</i></code>
      displays the same help in the default web browser,
      but with better formatting.
    </div>
    <div>
      Other great sources of help include:
    </div>
    <ul>
      <li>
        Github repo at
        <a href="https://github.com/fish-shell/">https://github.com/fish-shell/</a>
      </li>
      <li>
        Wikipedia page at
        <a href="https://en.wikipedia.org/wiki/Friendly_interactive_shell">https://en.wikipedia.org/wiki/Friendly_interactive_shell</a>
      </li>
      <li>
        official mailing list at
        <a href="mailto:fish-users@lists.sourceforge.net">fish-users@lists.sourceforge.net</a>
      </li>
      <li>Stackoverflow at
        <a href="https://stackoverflow.com/questions/tagged/fish">https://stackoverflow.com/questions/tagged/fish</a>
      </li>
      <li>IRC channel #fish on irc.oftc.net</li>
    </ul>

    <h3>Starting Fish</h3>
    <div>
      Once fish has been installed, to start a fish shell from a terminal,
      enter <code>fish</code>.
      To exit a fish shell, enter <code>exit</code>.
    </div>

    <h3>Default Shell</h3>
    <div>
      To make fish the default shell so new terminal windows automatically use it,
      enter <code>chsh -s /usr/local/bin/fish</code>.
      TODO: Does this assume the current shell is bash?
    </div>

    <h3>Autosuggestions</h3>
    <div>
      Autosuggestions suggest remaining text for a command
      while the command is being typed.
      Typically this appears as gray text,
      sometimes referred to as ghosting,
      but the color can be customized.
      It derives suggestions from command history,
      possible commands, possible switches (a.k.a. options),
      variables, and file paths.
    </div>
    <div>
      If the suggestion is not desired, continue typing.
      To accept a suggested completion, press the right arrow.
      To execute the command, press enter.
    </div>
    <div>
      Possible commands and switches are derived from
      man pages that fish has parsed.
      If new man pages are installed,
      enter <code>fish_update_completions</code> to parse them.
    </div>

    <h3>Tab Completions</h3>
    <div>
      Autosuggestions only provide one suggestion.
      To see more options, press tab.
      This presents a list of options that includes
      command names, switches, variable names,
      file paths,
      git branch names (including remote branches),
      process names/ids
      job names/ids,
      man page names
      ssh hosts,
      users (ex. su and press tab to see all usernames),
      and more
    </div>
    <div>
      If there is only one option, it will be expanded in place
      If there is more than one option,
      up to four rows will be listed.
      If there are more than four rows of options,
      they will be followed by "...and n more rows".
      To see the remaining options, press tab again.
      Highlighting cycles back to first option
      if tab is pressed while the last option is highlighted.
      To select an option, press tab repeatedly until
      the desired option is highlighted
      and press enter to accept it.
      Press enter again to execute the command.
    </div>
    <div>
      To filter the list of options,
      press tab until an option is highlighted,
      then type a substring that must be contained in the options.
      A search entry field starting with "search:" will be displayed.
      To skip selecting an option, press the escape key.
    </div>
    <h4>Examples</h4>
    <div>
      To list files in the current directory whoses names begin with "d",
      enter <code>ls d</code> and press tab repeatedly
      until the desired variable is highlighted.
      This also works when only <code>ls</code> entered
      before pressing tab.  In this case the options are
      all files in the current directory.
    </div>
    <div>
      To output the value of a variable whose name begins with "re",
      enter <code>echo $re</code> and press tab repeatedly
      until the desired variable is highlighted.
    </div>
    <div>
      To kill a process whose name contains "lo",
      enter <code>kill lo</code> and press tab repeatedly
      until the desired process is highlighted.
    </div>
    <div>
      To get help on a command that contains "lo",
      enter <code>man lo</code> and press tab repeatedly
      until the desired command is highlighted.
    </div>

    <h3>Custom Tab Completions</h3>
    <div>
      Tab completions can be defined for custom commands
      using the <code>complete</code> command.
      This is an advanced topic.
    </div>
    <div>
      The syntax is
      <code>complete -c <i>command-name</i> -s <i>short-switch</i> -l <i>long-switch</i> -a '<i>argument words</i>'</code>
    </div>
    <div>
    <div>
       TODO: See your functions/greet.fish and completions/greet.fish example
       which is not working yet.
       Also see https://fishshell.com/docs/current/commands.html#complete
       and https://fishshell.com/docs/current/index.html#completion-own.
    </div>

    <h3>Command History</h3>
    <div>
      All commands entered except those that begin with a space
      (which are treated like incognito commands)
      are saved in command history.
      This exception may be removed in fish 3.
      Duplicate commands are automatically removed,
      retaining only their most recent occurrence.
    </div>
    <div>
      Command history is stored in <code>~/.local/share/fish/fish_history</code>.
      This file stores each command and when it was entered.
    </div>
    <div>
      To list all commands in the hisory, enter <code>history</code>.
    </div>
    <div>
      To list only commands that contain a given substring,
      enter <code>history <i>text</i></code>.
      This is the same as entering
      <code>history search --contains <i>substring</i></code>.
      <code>-c</code> is short for <code>--contains</code>.
    </div>
    <div>
      To list only commands that begin with a given prefix,
      <code>history search --prefix <i>prefix</i></code>.
      <code>-p</code> is short for <code>--prefix</code>.
    </div>
    <div>
      To include the date and time that commands were issued,
      add the <code>--show-time-prepends</code> (<code>-t</code>) switch.
    </div>
    <div>
      To limit the number of commands output,
      add the <code>--max</code> (<code>-n</code>) switch followed by a number.
      For example, <code>history -n 5</code>.
    </div>
    <div>
      To clear all command history, enter <code>history clear</code>.
    </div>
    <div>
      To delete commands from history that contain a given substring,
      enter <code>history delete --contains <i>substring </i></code>.
    </div>
    <div>
      To delete commands from history that begin with a given prefix,
      enter <code>history delete --prefix <i>prefix </i></code>.
    </div>
    <div>
      To navigate through all previously entered commands
      press the up and down arrow keys.
      Press enter to execute the displayed command
      or press ctrl-c to exit without executing one.
      To restrict to commands that contain a given substring,
      type the substring before pressing the arrow keys.
    </div>

    <h3>Changing Working Directory</h3>
    <div>
      Like in other shells, the current working directory
      can be changed by using the <code>cd</code> command.
      However, since the initial character of directory paths
      (<code>.</code>, <code>/</code>, and <code>~</code>)
      is not a valid character in any command,
      fish interprets just entering a directory path
      as a request to change the working directory.
      For example, entering
      <code>~</code> cds to your home directory and
      <code>..</code> cds to the parent directory.
    </div>
    <div>
      Tab completion can be used to assist in
      entering each part of a directory path.
      This even works without entering anything,
      so it's possible to navigate to any child directory
      by just pressing tab repeatedly
      until the desired directory name is highlighted
      and then pressing enter once to select it
      and again to execute the command.
    </div>
    <div>
      Like in other shells, to get the current working directory
      enter <code>pwd</code>.
    </div>
    <div>
      The <code>dirh</code> command prints list of last 25 directories visited.
      The current directory will be highlighted.
      To go back one, enter <code>prevd</code> or
      press alt-left (in macOS, cmd-option-left).
      To go forward one, enter <code>nextd</code> or
      press alt-right (in macOS, cmd-option-right).
      This is a very convenient way to change to a previous directory!
    </div>
    <div>
      In addition, a stack of past directories is maintained.
      To push a new directory onto the stack and cd to it,
      enter <code>pushd <i>directory</i></code>.
      To pop the current directory off the stack
      and cd to the directory now at the top,
      enter <code>popd</code>.
      It is not possible to pop the list directory off the stack.
      To view the current directory stack, enter <code>dirs</code>.
    </div>

    <h2>Customizing Fish</h2>

    <div>
      The fish shell can be configured in three ways:
      by executing commands in a shell,
      adding commands in a configuration file,
      and in a web UI.
    </div>

    <h3>Configuration via Web UI</h3>
    <div>
      To start the web UI, enter
      <code>fish_config <i>starting-tab-name</i></code>.
      Specifying the starting tab name is optional
      and defaults to "colors".
      This starts a local web server and
      opens a new tab in the default web browser.
      This UI contains seven tabs that are described below.
    </div>
    <div>
      The "colors" tab displays the current color settings
      and allows them to be customized.
      To use a provided color theme, select one,
      press the "Set Theme!" button, and
      wait a few seconds for it to change to "Theme Set!"
    </div>
    <img src="config-colors.png" alt="color config screenshot">
    <div>
      Colors can be customized for the following syntax elements:
      commands, parameters, statement terminators, quoted strings,
      redirections, errors, comments, and autosuggestions.
      To customize one of these, click the corresponding syntax example
      near the top of the UI and
      select a color from the color grid below.
      When finished customizing the colors,
      press the "Set Theme" button.
      Note that these colors are not used when fish function definitions
      are simply cat'ed in a terminal.
    </div>
    <div>
      While the "color" tab allows seelcting a background color,
      this is only for seeing how the other colors look
      against that background.
      It does not actually change the terminal background color.
      If using iTerm2 in macOS, the bacground color can be changed by
      selecting Preferences...Profiles...Colors...Background.
    </div>
    <div>
      The "prompt" tab displays then contents
      of the current fish shell prompt.
      It allows selection from 17 predefined prompts.
      To change the prompt, select one and press "Prompt Set!"
      DANGER: This overwrites <code>functions/fish_prompt.fish</code>,
      so if you have defined a custom prompt in that file,
      and don't want to wipe it out, don't do this!
    </div>
    <img src="config-prompt.png" alt="color config screenshot">
    <div>
      The "functions" tab provides a read-only view
      of all functions that have been defined.
      Select a function name to see its definition
      which includes all the commands it executes.
    </div>
    <img src="config-functions.png" alt="color config screenshot">
    <div>
      The "variables" tab provides a read-only view
      that lists all universal variables and their values.
      This does not list global or local variables.
    </div>
    <img src="config-variables.png" alt="color config screenshot">
    <div>
      The "history" tab provides a read-only view
      of your command history in the order in which commands
      were issued from a terminal starting with the most recent commands.
    </div>
    <img src="config-history.png" alt="color config screenshot">
    <div>
      The "bindings" tab provides a read-only view
      that lists the current key bindings.
    </div>
    <img src="config-bindings.png" alt="color config screenshot">
    <div>
      The "abbreviations" tab provides a read-only view
      that lists all abbreviations.
      Often these are defined in <code>config.fish</code> (discussed later),
      but they can be defined from a terminal.
    </div>
    <img src="config-abbreviations.png" alt="color config screenshot">
    <div>
      Pressing the enter key in the terminal where
      the <code>fish_config</code> command was entered
      shuts down the server that serves this web UI.
      To restart it, enter <code>fish_config</code> again,
      which will also open a new browser tab.
    </div>

    <h3>Configuration via fish.config</h3>
    <div>
      Fish is billed as not needing configuation.
      Strictly speaking this is true,
      but if you currently use another shell like bash,
      you likely have configuration for it
      (in <code>~/.bash_profile</code> and <code>~/.bashrc</code>)
      and will want similar configuration for fish.
      Examples include creating aliases and abbreviations,
      and setting variables such as PATH.
    </div>
    <div>
      The fish configuration file is named <code>config.fish</code>
      and should be placed in the <code>~/.config/fish</code> directory.
      Saving configuration here enables
      copying that file to other machines
      where the same configuration is desired.
    </div>
    <div>
      A "login shell" is created for every new terminal window.
      For users of tmux, this includes creating new tmux panes.
      An "interactive shell" is created when a subshell is created.
      For example, this happens when the command <code>fish</code>
      is entered in a fish shell.
      Login shells are also considered interactive shells.
    </div>
    <div>
      Inside <code>config.fish</code>,
      to run commands only when starting a login shell,
      place the commands inside an <code>if</code> command as follows:
      <code>if status --is-login; ...; end</code>.
      To run commands only when starting an interactive shell, use
      <code>if status --is-interactive; ...; end</code>.
    </div>
    <div>
      While functions can be defined in <code>config.fish</code>,
      it is more efficient to use autoloading functions.
      These are discussed later.
    </div>

    <h3>Aliases</h3>
    <div>
      An alias is an alternate name, usually shorter, for some command.
    </div>
    <div>
      To define an alias, enter <code>alias name <i>command </i></code>.
    </div>
    <div>
      To list all aliases, enter <code>alias</code>.
    </div>
    <div>
      To remove an alias, enter <code>functions -e <i>name </i></code>.
    </div>
    <div>
      Defining an alias creates a function with the specified name
      that runs the command.  Functions are described later.
      The function is only defined in the current session
      and goes away when the session exits.
      To create aliases that are available in all sessions,
      define them in <code>config.fish</code>.
      For more information, see "Defining aliases" at
      <a href="https://fishshell.com/docs/current/index.html#introduction">https://fishshell.com/docs/current/index.html#introduction</a>.
    </div>

    <h3>Abbreviations</h3>
    <div>
      In addition to aliases, fish supports abbreviations.
      These are similar, but expand when typed.
    </div>
    <div>
      To define an abbreviation, enter
      <code>abbr --add <i>name</i> <i>value </i></code> (-a).
    </div>
    <div>
      For example, the following defines an abbreviation
      for checking out a git branch:
      <code>abbr -add co git checkout</code>.
      Once this is defined, "co" followed by a space can be entered
      in a terminal and that will be expanded to "git checkout".
      Continue typing a branch name and press enter to execute the command.
      The branch name is often auto-suggested and can be tab completed.
    </div>
    <div>
      Unlike aliases, when abbreviations are defined in a terminal
      (as opposed to inside <code>config.fish</code>),
      they become available in all sessions.
      In general, abbreviations are preferred over aliases.
    </div>
    <div>
      To output a list of all abbreviation names,
      enter <code>abbr --list</code> (<code>-l).
    </code> </div>
    <div>
      To output a list of all abbreviation names and their values,
      enter <code>abbr --show</code> (<code>-s</code>)
      or just <code>abbr</code>.
    </div>
    <div>
      To delete (erase) an alias,
      enter <code>abbr --erase <i>name</i></code> (<code>-e</code>).
    </div>

    <h3>Variables</h3>
    <div>
      Variable names in fish consist of letters, digits, and underscores.
      All variable values are lists that hold zero, one, or more string values.
      Variable names are case-sensitive.
      <code>myvar</code> and <code>myVar</code> are different variables.
    </div>
    <div>
      There are three variable scopes.
    </div>
    <div>
      Local variables available only in the current block
      Blocks begin with one of these commands,
      each of which are discussed later:
      <code>begin</code>, <code>if</code>, <code>for</code>,
      <code>function</code> , <code>switch</code>,
      or <code>while</code>.
      Blocks are terminated by a corresponding <code>end</code> keyword.
    </div>
    <div>
      Global variables are available anywhere in the current session.
    </div>
    <div>
      Universal variables are available in every session.
      They are even available in future sessions
      because they are saved across reboots
      Settings of universal variables are stored in
      <code>~/.config/fish/fishd.<i>machine-id</i></code>.
    </div>
    <div>
      Regardless of scope, every variable is set using the command
      <code>set <i>name </i> <i>value </i></code>.
      This command accepts many switches.
    </div>
    <div>
      To make a variable local, add <code>--local</code> (<code>-l</code>).<br>
      To make a variable global, add <code>--global</code> (<code>-g</code>).<br>
      To make a variable universal, add <code>--universal</code> (<code>-U</code>).<br>
      To export a variable so it is visible in child processes,
      add <code>--export</code> (<code>-x</code>).
      Note that this is not a new kind of scope.
      It is convention for exported variable names to be all uppercase.
    </div>
    <div>
      The same variable name can be assigned a different value
      in each scope.  The value used depends on context,
      using the lowest scope visible, local then global then universal.
    </div>
    <div>
      What happens when a variable is set without specifying a scope
      depends on whether it has been previously set.
      If the variable has already been set in any scope,
      this changes the value of the lowest visible scope already set.
      If the variable has not already been set in any scope,
      the new variable will be local to the function in which it is set,
      not the block where it is set.
      If not in a function, the variable will be global
      When a variable is set in <code>config.fish</code>
      with no scope switch, it becomes global.
    </div>
    <div>
      To get the value of a variable use <code>$<i>name</i></code>.
      If this appears next to other text,
      say the strings "foo" and "bar",
      use <code>foo{$<i>name</i>}bar</code>
      or <code>'foo'$<code>name</code>'bar'</code>.
    </div>
    <div>
      To delete (or erase) a variable,
      enter <code>set --erase <i>name</i></code> (<code>-e</code>).
      This will delete the variable from the closest scope
      in which it is currently defined,
      considering local, then global, then universal.
      A scope can also be specified using the
      <code>--local</code> (<code>-l</code>),
      <code>--global</code> (<code>-g</code>), and
      <code>--universal</code> (<code>-U</code>) switches.
    </div>
    <div>
      To list the names and values of all variables
      in the lowest in which they can be found,
      enter <code>set</code>.
      A scope switch can also be specified
      to list only the variables in that scope.
      To list all variables that have been exported,
      add the <code>--export</code> switch.
    </div>
    <div>
      To list only the names of all defined variables,
      enter <code>set --names</code> (<code>-n</code>).
      A scope switch can also be specified
      to list only the variable names in that scope.
    </div>
    <div>
      To determine if a variable has been set (query),
      enter <code>set --query <i>name</i></code> (<code>-q</code>).
      This sets the status variable to 0 if set and 1 if not.
      For example, <code>set -q fish_greeting; echo $status</code>.
      A scope switch can also be specified to query only in that scope.
    </div>
    <div>
      A variable can be set and not have a value.
      For example, <code>set foo</code>
      sets the variable <code>foo</code>, but it doesn't have a value.
      This is similar to setting a variable to <code>null</code>
      in JavaScript versus <code>undefined</code>.
      To determine if a variable has a value,
      enter <code>set -q name[0]</code>
      and verify that status is set to zero.
    </div>
    <div>
      To interactively edit the value of a variable,
      enter <code>vared <i>name</i></code>.
      This is useful for values that are long strings.
      It cannot be used to edit values that are lists
      containiner more than one item.
      To edit a specific item in a list,
      specify the item index.
      For example, if the variable colors holds a list of colors,
      the third color can be edited with <code>vared colors[3]</code>.
    </div>

    <h3>Advanced Use of Variables</h3>
    <div>
      Move this section down!
    </div>
    <div>
      Multiple $'s can be used to interpret the value of a variable
      as a variable name.  Consider the following examples.
    </div>
    <pre>
set foo 1
set bar foo
echo $$bar # 1

set pocket 'wallet'
set pant pocket
echo $$pant # wallet

set foreground blue
set background green
set side fore
set name "$side"ground
echo $$name # blue</pre>
    <div>
      From
      <a href="https://fishshell.com/docs/current/index.html#expand-variable">https://fishshell.com/docs/current/index.html#expand-variable</a>,
      "When using this feature together with array brackets,
      the brackets will always match the innermost $ dereference."
      To understand this, consider the following example.
    </div>
    <pre>
set colors red green blue
set listName colors</pre>
    <div>
      How can we write code to get the value "green"
      from the list of colors?
    </div>
    <div>
      <code>echo $$listName[2]</code>
      doesn't work because it evaluates like
      <code>tmp = $listName[2]</code>
      and then <code>$tmp</code> on that.
      <code>$listName[2]</code> gives array index out of bounds
      because the value of <code>$listName</code> is just
      <code>'colors'</code> and that has no value at index 2.
    </div>
    <div>
      <code>echo $$listName[1][2]</code> works!
      <code>$$listName[1][2]</code> evaluates like
      <code>$listName[1]</code> which gives <code>'colors'</code>
      and then <code>$colors[2]</code> which gives <code>'green'</code>.
    </div>

    <h3>Strings</h3>
    <div>
      Literal string values are specified by enclosing text
      in single or double quotes.
      Variable substitution occurs in double quotes, but not in single.
      For example, the reference to <code>$USER</code>
      in the following is replaced by its value:
      <code>set msg "Good morning, $USER. Have a great day!"</code>
    </div>
    <div>
      In a single quoted string,
      single quotes can be escaped with <code>\'</code>
      and backslashes can be escaped with <code>\\</code>.
      In a double quoted string,
      double quotes can be escaped with <code>\"</code>.
      <code>$</code> which is used for variable substitution
      can be escaped with <code>\$</code>
      and backslashes can be escaped with <code>\\</code>.
    </div>
    <div>
      The <code>string</code> command has many subcommands
      that are specified by following <code>string</code>
      with a space and the name of the subcommand.
      To suppress output from these and
      just use the value of the status variable,
      add the <code>--quiet</code> (<code>-q</code>) switch.
    </div>
    <div>
      To get the length of a string, use
      <code>string length $<i>name</i></code>
    </div>
    <div>
      Literal strings can be concatenated with the value of a variable.
      For example,
    </div>
    <pre>
set middle 'some middle'
set result 'some prefix'$middle'some suffix'</pre>
    <div>
      These are similar, but result in a list with count of 3.
    </div>
    <pre>
set result some prefix"$middle"some suffix
set result some prefix{$middle}some suffix</pre>
    <div>
      Here are some tests than can be performed on
      variables that hold a single string.
    </div>
    <ul>
      <li>is empty?: <code>if test -z $<i>var</i></code></li>
      <li>is not empty?: <code>if test -n $<i>var</i></code></li>
      <li>is identical to another?: <code>if $<i>var1</i> = $<i>var2</i></code></li>
      <li>is not identical to another?: <code>if $<i>var1</i> != $<i>var2</i></code></li>
    </ul>
    <div>
      Current there is no way in fish to test whether
      one string is less than or greater than another in sorting order.
      The <code>&lt;</code> and <code>&gt;</code> operators
      are only implemented for numbers.
      TODO: Is there any workaround for this?
    </div>
    <div>
      String indexes start at 1, not 0.
      To get a substring, use
      <code>string sub $<i>name</i> -s <i>startIndex</i> -l <i>length</i></code><br>
      If <code>-s</code> is omitted, it defaults to <code>1</code>.
      If <code>-l</code> is omitted, this gets characters to the end.
      If <code>-s</code> is negative, it counts from the end of the string.
      For example, to get last three characters, use <code>-s -3</code>.
    </div>
    <div>
      To split a string on a delimiter resulting in a list, use
      <code>string split <i>delim</i> $<i>var</i></code><br>
      For example,
    </div>
    <pre>
      set csv 'red,green,blue'
      set colors (string split , $csv) # red gree blue</pre>
    </div>
    <div>
      To trim leading and/or trailing characters, use
      <code>string trim $<i>var</i></code><br>
      By default, this trims whitespace from both ends of the string.
      Switches can be used to change this.
    </div>
    <ul>
      <li><code>--left</code> (<code>-l</code>) to only trims from left</li>
      <li><code>--right</code> (<code>-r</code>) to only trim from right</li>
      <li><code>--chars</code> (<code>-c</code>) specifies
        characters to be trimmed instead of whitespace</li>
    </ul>
    <div>
      For example, to remove leading zeros,<br>
      <code>set result (string trim --left --chars 0 00019) # 19</code>
    </div>
    <div>
      To create a new string by joining existing ones
      using a delimiter between them, use <code>string join</code>.
      For example,<br>
      <code>set dateStr (string join '/' $month $day $year)</code>
    </div>
    <div>
      Another example is getting initials from a full name.
      Note how <code>string sub</code> can be used to get
      substrings from multiple strings in one call.
      Also note how the delimiter passed to <code>string join</code>
      can be an empty string.
    </div>
    <pre>
      set initialList (string sub -l 1 $first $middle $last)
      set initials (string join '' $initialList)</pre>
    <div>
      To create a string that repeats a given string,
      use <code>string repeat</code> with the
      <code>--count</code> (<code>-n</code>) switch
      For example,<br>
      <code>set newText (string repeat -n3 'foo') # foofoofoo</code>
    </div>

    <h3>Regular Expressions</h3>
    <div>
      To determine if a string matches a regular expression,
      use <code>string match</code> subcommand
      with the <code>--regex</code> (<code>-r</code>) switch.
      This uses Perl regular expression syntax.
      By default, only the first match is output,
      or nothing if not found.
      This sets status to 0 if at least one match was found and 1 if not.
    </div>
    <div>
      For example,
    </div>
    <pre>
set name 'Mark Volkmann'
string match -qr 'Vo' $name
echo $status # 0 for found
    </pre>
    <div>
      To output all matches, add the
      <code>--all</code> (<code>-a</code>) switch.
      To make matching case-insenstive,
      add the <code>--ingore-case</code> (<code>-i</code>) switch.
      To get indexes and lengths of matches instead of matching text,
      add the <code>--index</code> (<code>-n</code>) switch.
    </div>
    <div>
      Regular expressions can use capture groups.
      In this case, <code>string match</code> outputs a list containing
      the full match followed by each capture match.
    </div>
    <div>
      To determine if a string doesn't match,
      add the <code>--invert</code> (<code>-v</code>) switch.
    </div>
  * ex.
    set text 'this is foolish work for a boolean'
    set matches (string match -ar '.oo' $text) # foo boo
    set matches (string match -anr '.oo' $text) # 9 3 28 3
    - result is alternating list of indexes and lengths
    <div>
    </div>
    <div>
    </div>
- to replace text in a string with other text
  * string replace is similar to string match
  * can match against literal text or a regex (using -r)
  * ex. replace all occurrences of "foo" with "bar"
    set text 'this is foolish work for a fool'
    set newText (string replace -a 'foo' 'bar' $text)
  * when using a regex, can use capture groups

    <h3>Numbers</h3>
    <div>
      Only integers are supported, not floating point,
      When a variable is set to a number, it is stored as a string.
    </div>
    <div>
      For example, if <code>set score 12345</code> is entered,
      the variable score will be set to a string containing
      the five characters "12345".
    </div>
    <div>
      To test the relationship between two numbers,
      use the <code>test</code> command.
      This supports many switches for various comparisons.
      Both operands must be numbers or
      strings that only contain digits which are converted to numbers.
    </div>
    <ul>
      <li>equal: <code>if $n1 -eq $n2</code></li>
      <li>not equal: <code>if test $n1 -ne $n2</code></li>
      <li>less than: <code>if test $n1 -lt $n2</code></li>
      <li>less than or equal: <code>if test $n1 -le $n2</code></li>
      <li>greater than: <code>if test $n1 -gt $n2</code></li>
      <li>greater than or equal: <code>if test $n1 -ge $n2</code></li>
    </ul>

    <h3>Dates</h3>
    <div>
      The <code>date</code> command outputs the current date.
      The default format looks like "Sat Aug 26 16:54:52 CDT 2017".
      To use a different format, specify it using a format string
      as defined by <code>strftime</code>
      For details, enter <code>man strftime</code>.
    </div>
    <div>
      For example, to format the date as "Saturday August 26, 2017"
      enter <code>date '+%A %B %d, %G'</code>
    </div>

    <h3>Lists (a.k.a Arrays)</h3>
    <div>
      Recall that the value of all variables is a list which
      may contain any number of items, including just one.
      Lists contain string values.
      They cannot contain other lists.
    </div>
    <div>
      To create an empty list,
      enter <code>set <i>name</i></code>
    </div>
    <div>
      To create a non-empty list,
      enter <code>set <i>name </i> <i>item1 </i> <i>item2 </i> ...</code>
    </div>
    <div>
      For example, <code>set colors red green blue</code>
      is equivalent to <code>set colors 'red' 'green' 'blue'</code>.
      Neither of these is equivalent to <code>set colors 'red green blue'</code>
      in which the value of <code>colors</code> is set to a single string.
    </div>
    <div>
      To append an item to a list, enter
      <code>set <i>name </i> $<i>name</i> <i>newItem</i></code>
    </div>
    <div>
      To append an item to a list, enter
      <code>set <i>name </i> <i>newItem</i> $<i>name</i></code>
    </div>
    <div>
      To get an item from a list by index,
      enter <code><i>name</i>[<i>index</i>]</code><br>
      Indexes start at 1, not 0.
      Use negative indexes to retrieve from the end of the list.
      For example, <code><i>name</i>[-1]</code> gets the last item.
    </div>
    <div>
      To set an item by index,
      <code>set <code>name</code>[<i>index</i>] <i>value</i></code>
    </div>
    <div>
      To get a slice which is a new list, use
      <code><i>name</i>[<i>start</i>..<i>end</i>]</code><br>
      <code><i>start</i></code> and <code><i>end</i></code>
      can be positive or negative.
    </div>
    <div>
      To test whether an item is in a list, use<br>
<pre>
if contains <i>item</i> $<i>name</i>
  # code goes here
end</pre>
    <div>
      The <code>contains</code> command sets <code>status</code>
      to 0 if found and 1 if not.
    </div>
    <div>
      To get the index of an item in a list, use<br>
      <code>contains --index <i>item</i> $<i>name</i></code> (<code>-i</code>)
    </div>
    <div>
      To remove an item from a list, use
    </div>
<pre>
if set -l index (contains -i <i>item</i> $<i>name</i>)
  set -e <i>name</i>[$index]
end</pre>
    <div>
      To create a reversed version of an existing list, use
      <code>set <i>newName</i> <i>existingName</i>[-1..1]</code>
    </div>
    <div>
      To get the length of a list, use
      <code>count $<i>name</i></code>
    </div>
    <div>
      To iterate over all the items in a list, use
<pre>
for <i>item</i> in $<i>name</i>
  # use $<i>item</i> here
end</pre>
    </div>
    <div>
      Adjacent lists result in cartesian products.
      For example,
    </div>
<pre>
set columns a b c
set rows 1 2
set cells $columns$rows # a1 b1 c1 a2 b2 c2
count $cells # 6

set dashedCells $columns'-'$rows # a-1 b-1 c-1 a-2 b-2 c-2

set labels "Column "$columns # Column a Column b Column c
count $labels # 3

set cells {a,b,c}{1,2} # a1 b1 c1 a2 b2 c2</pre>
    <div>
      Note that spaces cannot appear around the commas
      in the last example.
    </div>
    <div>
      When a fish shell is started,
      if the variables <code>PATH</code>, <code>CDPATH</code>, or <code>MANPATH</code> exist,
      they are converted to lists by splitting on colons.
    </div>

    <h3>Hashmaps</h3>
    <div>
      Hashmaps are not currently supported, but have been discussed at
      <a href="https://github.com/fish-shell/fish-shell/issues/390">https://github.com/fish-shell/fish-shell/issues/390</a>.
      They will be added in fish 3.
    </div>
    <div>
      Hashmaps can simulated with plain variables,
      but there isn't a way to iterate over the keys
      unless they are held in a list.
      For example,
    </div>
    <pre>
set colors red green blue
set items_red fire
set items_green grass
set items_blue water
for color in $colors
  eval echo '$'items_$color
end</pre>

    <h3>PATH environment variable</h3>
    <div>
      <code>PATH</code> is a variable that holds a lists of paths
      that the shell searches when a command is entered.
      <code>PATH</code> is a global variable, which means that
      changes to it are available anywhere in the current session,
      but not in others.
      Its value is not a colon-separated string like in other shells.
      It is a list of space-separated strings that is treated like an array.
    </div>
    <div>
      Typical PATH is defined in <code>config.fish</code>.
    </div>
    <div>
      To see the current value, enter <code>echo $PATH</code>.
    </div>
    <div>
      The universal variable <code>fish_user_paths</code>
      is another list of paths that is
      automatically prepended to <code>PATH</code>.
      Seting this modifies <code>PATH</code> in a way that
      affects all current and future sessions
      without having to modify <code>config.fish</code>
      and source it again.
      However, a benefit of changing PATH in <code>config.fish</code>
      is that the file can easily be copied to other machines.
    </div>
    <div>
      <code>fish_user_paths</code> should only be set in a terminal,
      not in <code>config.fish</code>.
    </div>
    <div>
      To prepend a path to PATH,<br>
      <code>set -U fish_user_paths $fish_user_paths <i>new-path</i></code><br>
      This outputs a warning if <code><i>new-path</i></code>
      doesn't exist, but adds it anyway.
      TODO: see .config/fish/functions/addpath.fish
    </div>
    <div>
      As we will see later, all variables hold a list.
      It's just that many of them only contain a single value.
      Removing a path from PATH or fish_user_paths is done
      the same way as removing an item from any list.
    </div>
    <div>
      To remove a path from fish_user_paths:
    </div>
    <code>
      if set -l index (contains -i <i>some-path</i> $fish_user_paths)
        set -e fish_user_paths[$index]
      end
    </code>

    <h2>Scripting in Fish</h2>

    <div>
      If you appreciate programming languages with simple, consistent syntax,
      you will love scripting in fish!
    </div>
    <div>
      Scripts are implementing by writing a function.
      Functions become custom commands that can be executed from a terminal.
      A function is defined by using the <code>function</code> command.
      Functions can have named parameters.
      Functions cannot return a value,
      but they can write to a stream like stdout and stderr and
      they can set a return status that goes into the variable <code>status</code>.
      When a function is called, whatever it writes to stdout
      can be captured in a variable with
      <code>set myVar (myFunction args)</code>
    </div>
    <div>
      In other shells, many steps are required to write and enable a new script.
    </div>
    <ul>
      <li>Decide where to create the implementation file.</li>
      <li>Create the file and write the code.</li>
      <li>Make sure the directory is listed in the PATH environment variable.</li>
      <li>Add a "shebang" comment as the first line.</li>
      <li>Use the <code>chmod</code> command to make the file executable.</li>
    </ul>
    <div>
      While the same can be done with fish scripts,
      most of these steps are not necessary.
      The easiest way to write and enable a new fish script is:
    </div>
    <ul>
      <li>
        Enter <code>funced <i>name </i></code>.
        This opens an editor for entering or modifying the script.
        If the script is new, the editor is populated with
        a starting point for a function definition.
      </li>
      <li>
        Write or modify the code and save the changes.
        If the function was previously defined in a file,
        this will not update the file!
      </li>
      <li>
        Enter <code>funcsave <i>name </i></code>.
        This saves the script to a file with the same name as the function
        in the ~/.config/fish/functions directory.
        When commands are executed, fish automatically looks
        for their implementation here.
        If this step is skipped, the function can still be used as a command,
        but it won't be available in other existing or future sessions.
      </li>
    </ul>

    <h3>Comparing fish functions to JavaScript</h3>
    <div>
      Let's look at an example of a simple function that
      takes two numbers and outputs their product.
      It's useful to see how fish functions differ from
      functions in more traditional programming languages like JavaScript.
    </div>
    <div>
      Here is the function in JavaScript and a call to it.
    </div>
    <code>
      function product(n1, n2) {
        return n1 * n2;
      }
      const result = product(2, 3); // 6
    </code>
    <div>
      Here is the function in fish and a call to it.
    </div>
    <code>
      function product -a n1 n2
        math "$n1 * $n2"
      end
      set result (product 2 3) # 6
    </code>
    <div>
       Everthing in fish is done with commands, even defining functions.
       The <code>-a</code> switch of the <code>function</code> command
       specifies named parameters
       Functions in fish cannot return a value,
       but they can write to streams like stdout.
       Math is performed using the <code>math</code> function
       which writes its result to stdout.
       Surrounding a function call with parens allows its stdout to be
       captured and placed in a variable.
    </div>

    <hr>

  * see .config/fish/functions/listrm.fish
  * see .config/fish/functions/rmpath.fish

LOOK FOR TODO IN THIS FILE!

For article
- create example script in Fish, Bash, and Node
  that lists files containing given text in their name
  in tree form that colors file types differently
  (ex. red for .js, blue for .scss, ...)
  * maybe make colors configurable
- separate into these sections
  * basic usage
  * minor customizations
  * writing functions
  * advanced
- get some ideas from the Wikipedia entry

Tools for fish (in alphabetical order)
- Fisherman - https://github.com/fisherman/fisherman
  * "The fish-shell plugin manager"
- Fundle - https://github.com/tuvistavie/fundle
  * "a minimalist package manager for fish inspired by Vundle"
- Oh My Fish - https://github.com/oh-my-fish/oh-my-fish
  * "provides core infrastructure to allow you to install packages
    which extend or modify the look of your shell"
- Tacklebox - https://github.com/justinmayer/tacklebox
  * "makes it easy to organize and share collections of
    useful shell functions, tools, and themes"

Colors
- all colors are customizable using the set_color command
  * outputs sequence of characters that change terminal text color
    for subsequently output text
  * can capture in a variable and output later
  * ex. set makeBlue (set_color blue); echo $makeBlue'I am blue'
- by default when entering commands,
  text is red until a valid command is entered
  and then it changes to white
- by default when typing file paths, the text is underlined
  unless no directory or file matches what has been typed
- specifying a color
  * color names
    - black, red, green, yellow, blue, magenta, cyan, white
    - brblack, brred, brgreen, bryellow, brblue, brmagenta, brcyan, brwhite
    - can list these with "set_color -c"
  * color values
    - 3 or 6 character hex
      * ex. f0f is full red, no green, and full blue which is purple
- set_color switches
  * --background (-b)
  * --print-colors (-c) prints list of named colors
  * --bold (-o) sets bold mode.
  * --dim (-d) sets dim mode
    - doesn't seem to have any effect in iTerm2
  * --italics (-i) sets italics mode
    - doesn't work in iTerm2
    - TODO: Is there any way to fix this?
  * --reverse (-r) sets reverse mode
  * --underline (-u) sets underlined mode
  * using set_color without these switches resets to default mode
- to reset all colors and switches, set_color normal
- variables that control colors
  * there are many that begin with "fish_color_"
    and "fish_pager_color_"
- ex.
  * echo Roses are (set_color red)red(set_color normal), \
      violets are (set_color blue)blue(set_color normal).
  * also see examples in your functions/fish_prompt.fish file

echo Command
- writes to stdout
- -n switch suppresses newline that is normally output at end
  * to beep, echo -n \a (it seems -n isn't needed)
- -s switch causes arguments to not be separated by spaces

printf Command
- writes to stdout using a format string
- printf format-string arg1 arg2 ...
- format specifiers
  * %d for decimal
  * %i for integer
  * %f for float
  * %s for string
  * %% for literal %
  * and more
- escapes
  * \a for bell
  * \n for newline
  * \t for tab
  * and more
- ex.
  set format 'my name is %s and i am '(set_color red)%i(set_color normal)' years old.'
  printf $format mark 56
- ex.
  set format 'my name is %s and i am %s%i%s years old.'
  printf $format mark (set_color red) 56 (set_color normal)

Commands
- every command is executed by entering its name
  followed by switches and arguments, if any, separated by spaces
  * it's hard to think of a programming language with such a consistent syntax
- commands are terminated by a newline or semicolon
  * in a shell, pressing enter produces a newline
  * semicolons allow multiple commands to appear on the same line
- multi-line commands
  * a short list of commands create a block
    - begin, for, function, if, switch, and while
    - these can span any number of lines and
      are terminated when the "end" keyword is reached
  * commands can split over multiple lines in two ways
    - by typing the \ continuation character and pressing enter
    - by pressing enter when there is an unterminated block
  * can be recalled and edited just like single-line commands
    - use up and down arrows to navigate between lines
- to include a space in an argument,
  preceded space with a backslash or
  enclose argument in single or double quotes
- arguments are expanded before commands are executed
  * this includes evaluating wildcards in file paths
- all commands set the "status" environment variable to
  0 for success and another number for failure
  * true and false are not boolean literals
  * false is a command that sets status to 1
  * true is a command that sets status to 0
- to execute one command and then execute a second command
  only if the first is successful
  * command1; and command2
  * note the semicolon at end of first command
  * note the use of "and" instead of "&&" like in bash
  * if the following is used instead and command1 has a bad status,
    command2 will still be executed
    - command1; command2
- to execute one command and then execute a second command
  only if the first failed
  * command1; or command2
  * note the use of "or" instead of "||" like in bash
- autoloading
  * every time a command is evaluated
    it first checks whether there is a file
    in any path listed in fish_function_path
    with the same name and a .fish extension
    - this typically contains ~/.config/fish/functions
      which is where user-defined functions are usually placed
    - if found and the file has not been loaded
      within the "staleness interval",
      it loads the file to get the current definition of the function
      and executes the function
      * the staleness interval avoids thrashing the file system
      * around 5 seconds
      * can source the file to avoid this delay
        - funced foo; and funcsave foo; and source foo.fish
    - does not search subdirectories of these paths
    - it is recommended that these files only define
      the function whose name matches the command
  * functions defined here
    - are immediately available in all fish shells
    - changes to them are automatically reloaded in all fish shells
      the next time they are used
  * this allows a function to be used in place of
    a command or builtin and executables in PATH
    - ex. function date; echo pwned date; end
      date outputs "pwned date" instead of the output of the date command
  * to run a command instead of a function with the same name
    - command name
  * to run a builtin instead of a function with the same name
    - builtin name

Wildcards
- ? matches a single character
- * matches any number of characters not containing /
- ** is like *, but also matches /
  which enables recursing into subdirectories

Pipes and Redirections
- pipe stdout of one command to the stdin of another
  with | like other shells
- for commands that read from stdin,
  to read from a file instead use < like other shells
  ex. some-command < file-path
- for commands that write to stdout,
  to write to a file instead use > like other shells
  ex. some-command > file-path
  * to avoid overwriting an existing file, use >?
  * to append, use >> instead of >
- for commands that write to stderr,
  to write to a file instead use ^ unlike other shells that use 2>
  * ex. some-command ^ file-path
  * but can also use 2>
  * to avoid overwriting an existing file, use ^?
  * to append, use ^^ instead of ^
- to redirect stderr to stdout, some-command 2>&1

Special Variables
- there are many variables whose names begin with "fish_"
  that control various things
- examples
  * CMD_DURATION is set to the duration of the last command in milliseconds
  * COLUMNS is set to # of columns in current terminal
  * FISH_VERSION is set to the version of the fish shell being used
    - the "version" variable is also set to this
    - can also output by entering "fish -v"
  * HOME is set to the user's home directory
  * LINES is set to # of lines (or rows) in current terminal
  * PWD is set to the current (or present) working directory
  * USER is set to the current username
  * _ holds the name of the currently executing command
  * fish_user_paths - see "PATH" section
  * status is set to the status of the last command
- internal variables
  * variables whose names begin with __FISH or __fish
    are for internal use and should not be used or changed

status Command
- has many subcommands
- examples that are useful inside functions defined in .fish files
  * status current-filename
  * status current-function
  * status current-line-number
    - this has issues
    - see https://github.com/fish-shell/fish-shell/issues/4161
  * status print-stack-trace

Files
- to test whether a file ...
  * exists: if test -e $file
  * is a file: if test -f $file
  * is a directory: if test -d $file
  * is a symbolic link: if test -L $file
  * is readable: if test -r $file
  * is writable: if test -w $file
  * is an executable file: if test -x $file
  * is a non-empty file (has size): if test -s $file
  * and more (see test command for details)
- to iterate over lines in a file
  * direct a file into a loop as follows:
    while read line
      # do something with the line
    end < file-path
- to open files using their default application
  * open file-path1 file-path2 ...
    - ex. open demo.html

Tests
- commmonly used in "if" and "while" statements
- tests for strings, numbers, and files
  are described in those sections
- to negate any test, add "!" before "test"
- two ways to combine conditions with "and" or "or"
  * option 1: place each command on a separate line where
    each line but the first begins with "and" or "or"
    - ex.
      test $color = 'yellow'
      and test $size = 'large'
    - "and" cannot be placed at the end of the first line
  * option 2: place -a or -o between the conditions
    - ex. test \( $color = 'yellow' \) -a \( $size = 'large' \)
    - this is too ugly! prefer option 1

Command Substitution
- to use the output of one command as an argument to another,
  surround the command with parens,
  not backticks like in some other shells
- if the command outputs more than one line,
  each will be treated as a separate argument
  to the outer command
- to set a variable to the output of a command
  * set name (command)
  * ex. set today (date)
- can concatenate command output with literal strings
  and other command output
  * ex.
    set dateFormat '+%A %B %d, %G' # ex. Tuesday, August 15, 2017
    set announcement 'Today is '(date $dateFormat)'.'
    - note the use of string concatention by placing
      literal strings next to the parens
- doesn't work inside strings
  * ex. the command is not evaluated in
    "Today is (date $dateFormat)."

Brace expansion
- used to produce multiple arguments for a command
- ex. ls *.{css,html.js} expands to ls *.css *.html *.js
- also useful in the cp and mv commands

Eval
- evaluates a command in a string
  that can be built using concatention and variable substitution
- ex.
  set extension '.js'
  set command ls *.$extension
  eval $command

Math
- the math function is a wrapper around the bc command
  (abbreviation for "basic calculator")
- supports floating point numbers
- converts strings to numbers
  * important because when a number is assigned
    to a variable, it is saved as a string
- pass a string containing a mathematical expression
- sets status to a non-zero number if expression is invalid
- writes result to stdout
- to limit number of decimal places in result, -sn
  where n is the number of decimal places to show
  - defaults to zero!
  - doesn't round properly!
- ex.
  set width 2
  set height 3
  set area (math "$width * $height") # 6
- some supported functions
  * sine: s(angle)
  * cosine: c(angle)
  * arctangent: a(angle)
  * natural logarithm: l(x)
  * e raised to a power: e(power)

Functions
- functions cannot return a value,
  but they can set the status variable
  and they can write to streams like stdout and stderr
- to capture stdout from a function in a variable
  * set result (someFn args)
  * ex.
    function product -a n1 n2
      echo (math "$n1 * $n2")
    end
    set result (product 3 4) # 12
- function names cannot begin with - and cannot contain /,
  but can contain any other characters, even spaces
  * to contain a space, prefix with \
    - ex. function foo\ bar; echo in foo bar; end
    - to call, foo\ bar
- a fish function is a list of commmands
  that are executed when the name of the function
  is used as a command in the shell
- to call a function, must specify its name
  * no parens around arguments or commas between them
- functions can be defined interactively
  by using the "function" command
  * this continues reading from stdin
    until it sees a line containing the closing "end"
- to define a function
  * function name
      # code goes here
    end
  * many switches can follow the function name
    - some are described later
    - to add documentation, --description "some desc"
      * or -d
      * displayed by "functions --details --verbose fn-name"
        in the fifth line
        - see --details below
      * see your fndesc.fish function that only displays description
- all functions are public
  * use prefixes for "private" functions
    to avoid name conflicts
    * ex. _prefix_name
- to make available in future sessions
  * define in files under .config/fish/functions
  * no need to mark these files as executable
  * no need to modify PATH
    - all are defined in functions directory
      * can they be in subdirectories to categorize them?
  * no need to add a shebang comment
    - all are assumed to be used only in the fish shell
  * these files are loaded the first time
    the function they define is called
  * name of file must match name of function
    - the autoloading mechanism for functions requires this
      * see more in "Commands" section
    - ex. define function foo in file named foo.fish
  * can define multiple functions in the same file,
    but they will not be available until the function
    whose name matches the file is called once
    - so doing this is not recommended
- to save a function definition that has been entered interactively
  in a file in .config/fish/functions
  * funcsave name
  * uses tabs for indentation
  * allows the function to be autoloaded in all future sessions
- to edit a function definition
  * funced name
  * if the function is not already defined, it will be created
  * uses editor in variable VISUAL that can be set in config.fish
    - defaults to emacs
    - ex. set VISUAL vim
  * emphasize using this and funcsave over
    manually creating files in the proper directory
    - after every use of funced, run funcsave to save changes
      in .fish file under ~/.config/fish/functions
  * why does it ask if a weird file should be removed after exiting editor?
    - What are the files under /var/folders/jc/...?
    - can delete them with find /var/folders/js -name '*.fish' -delete
- to format a .fish file
  * fish_indent < some-name.fish
    - writes to stdout
    - to output using colors specified in fish_config, add --ansi switch
    - to output as HTML, add --html switch
      * can add colors to specific syntax items with CSS
  * to read from a file and rewrite it with formatted version
    - fish_indent -w some-name.fish
  * uses four-space indentation and that cannot be customized,
    but can replace all occurrences for four spaces with two
    - see your fish_indent2.fish script
    - run with fish_indent2 name
    - creates a file with "-new" at end
    - TODO: Fix to overwrite the input file
- to list all currently defined functions
  * functions
    - add --all or -a to include functions that begin with an underscore
  * to view in web UI
    - fish_config functions
- to output the code for one or more functions
  * functions name1 name2 ...
- to see where a function is defined (its path)
  * functions --details name
    - or -D
  * if not saved to a file, will output "stdin"
- to see even more detail about a function
  * functions --details --verbose name
    - or -Dv
    - outputs these five lines
      * path to definition
      * whether it was autoloaded (outputs "autoloaded" or "n/a")
      * line number within file where definition begins
        or 0 if not autoloaded
      * whether "scope shadowing" was disabled
      * the function description specified with --description or -d
  * if not saved to a file, will output "stdin"
- to copy a function definition to a new name
  * functions --copy old-name new-name
    - or -c
  * only copies body, not switches
- to delete (erase) a function: functions -e name
  * doesn't remove automatically loaded functions
  * doesn't delete files that define them
  * just makes them inactive
- to test if a function exists
  * functions --query name
    - or -q
  * sets status
- return command
  - can use to exit before end
  * sets exit status of function which defaults to 0 for success,
    but can be specified
    - ex. return 2
- functions cannot return a value
  * they can only use the return command to return a status
  * but they can write to stdout
  * to set a variable to the stdout of a function
    - set var (fnname args)
    - ex.
      set width 2
      set height 3
      set area (math "$width * $height") # 6
- arguments
  * held in a list in $argv
    - first argument is in $argv[1]
  * iterate over arguments like iterating over any list
  * can also use named parameters
    - ex.
      function orderShirt -a color size
        # Use $color and $size here.
        # $argv is also set to a list of the arguments.
      end
    - all named parameters will be "set",
      but ones not specified will be set to an empty list
      * seems like a bad design
      * TODO: what's the rationale?
    - to test whether the named parameter is set,
      set -q name[1]
    - to set a named parameter to a default value,
      set -q name[1]; or set name 'default value'
- switches
  * to process command-line arguments as switches (a.k.a. options)
    for option in $argv
      switch "$option"
        case -h --help
          # code here
        ...
        case '*'
          # code here
      end
    end
- function do not have access to local variables set outside them
  * they are not closures
- if a function needs to output an error message, do this:
  set_color $fish_color_error
  echo errorMsg 1>&2
  set_color normal
  return some-non-zero-status

Auto-running Functions
- functions can run automatically when an event is fired
  * uses --on-event (-e) switch
  * ex.
    function takeShelter --on-event tornado
      echo Tornado warning! Take shelter!
    end
  * these functions are not auto-loaded
    - consider defining them in config.fish or
      sourcing files that define them from config.fish
      - source file-path
        * executes commands in the file without starting a new process
        * changes to variables will affect the current shell
  * can register any number of functions to run on the same event
  * events can be emitted with: emit event-name
    - event-name can be any string
    - event-name can be followed by any number of arguments
    - these become the value of the argv list inside functions
    - ex. emit tornado 'category 4' 12
  * events are only handled within the current process
  * fish generates these events:
    - fish_prompt: whenever a new fish prompt is about to be displayed
    - fish_command_not_found: whenever a command lookup failed
      * like Ruby's method_missing
    - fish_preexec: before executing an interactive command
      * the command line is passed as the first parameter
      * emitted even if the command is invalid
    - fish_postexec: after executing an interactive command
      * the command line is passed as the first parameter
      * emitted even if the command is invalid
- functions can run automatically when a variable changes
  * uses --on-variable (-v) switch
  * ex.
    function announcePath --on-variable PATH
      echo PATH is now $PATH
    end
    set -U PATH /foo $PATH
- a function can run automatically when a given process exits
  * uses --on-process-exit or -p
  * ex.
    function announceProcessExit --on-process-exit 12345
      echo an important process exited
    end
    function announceMyExit --on-process-exit %self
      echo I am exiting
    end
- a function can run automatically when signal is received
  * uses --on-signal or -s followed by a signal name or number
  * see https://www.tutorialspoint.com/unix/unix-signals-traps.htm
  * to see a list of supported signals, enter "kill -l"
  * ctrl-c sends an "int" signal
  * to send any signal to a given process
    - kill -sig pid
      where sig is a signal name or number
  * ex. to handle a kill of the current process
    function handleTermSignal --on-signal term
      echo received term signal
    end
    TODO: TRY THIS!

Types of commands
- a command is any program the shell can run
- there are three types of commands: builtins, commands, and functions
- builtins
  * commands that are provided by the shell
  * examples include: contains, echo, and if
  * to get a list of builtin names
    - builtin --names (or -n)
    - the "builtin" command can also be used to
      execute a specific builtin instead of a
      command or function with the same name
- commands
  * executables found in PATH
  * ex. chmod, ls, node, and vim
  * to get information about a command
    - command name
  * to get the path to a command
    - command --search name (-s name)
      or
      which name
    - the "command" command can also be used to
      execute a specific command instead of a
      builtin or function with the same name
- functions
  * some are provided by fish
    ex. abbr, cd, eval
  * user-defined functions can be defined in .fish files
    under ~/.config/fish/functions
  * aliases are converted to functions
  * there are many fish-specific functions
    whose names begin with "fish_"
  * to determine if a function is defined
    - functions --query name
      * sets status to 0 if defined or 1 if not
- to get the type of a name
  * type name
  * for functions, this also outputs their definition
  * to get just the type, type -t name

If statements
- if condition
    statements
  else if condition
    statements
  else
    statements
  end
- condition must be a command and its status is used
  * 0 is success and treated as true
  * any other value is an error and treated as false
  * opposite from most programming languages
- a common command to use in an "if" is "test"
  ex. if test $status # success
  ex. if test $status !- 0 # failure
- can negate condition being tested
  ex. if not test $status
  ex. if not any-command
- for a single line "if"
  * if condition; statement; end

and &amp; or commands
- note that these are commands, not keywords
- to conditionally execute a command only if $status is 0
  command1; and command2
  * this is the same as
    command1
    and command2
  * this is not the same as
    command1; command2
    because that will run command2 even if command1 has a bad status
- to conditionally execute a command only if $status is not 0
  command1; or command2
- these can be used in the condition of an "if" or "while"

Switch statements
- switch expression # ex. $color
  case value1 value2
    statements
  case value3
    statements
  case '*' # like default in other languages
    statements
  end
- expression should evaluate to a string
- each case can be followed by one or more values
  separated by spaces
  * values that do not contain special characters
    do not need to be in quotes
- does not fall through; no break at end of each case
- to treat one case value as the default
  case default-value '*'

Loops
- while condition
    # commands go here
  end
  * condition can use "and" and "or"
  * uses status of condition to determine whether to iterate again
    0 to continue; anything else to stop
  * for an endless loop, use "true" for condition
- for var in list
    # use var here
  end
  * to iterate over a list of numbers, use seq command
    - ex. for n in (seq 5); echo $n; end
      * outputs 1, 2, 3, 4, 5 on separate lines
    - seq can be followed by 1, 2 or 3 numbers
      to specify the first, increment, and last values
      * if only one, it is the last, first defaults to 1, and incr defaults 1
      * if only two, they are first and last, and incr defaults to 1
  * can iterate over relative file paths that match a pattern
    ex. for path in b*.fish; echo $path; end
- in both kinds of loops
  * use "break" to exit early
  * use "continue" to skip remainder of current iteration

Multiple statements on same line
- separate by semicolons
- ex. function foo; echo in foo; end

Custom Greeting
- by default, new fish shells display the greeting
  "Welcome to fish, the friendly interactive shell"
- to change this,
  set -U fish_greeting 'You are a fish!'
- to suppress this, erase the current setting with
  set -e fish_greeting

Custom Prompt
- the default fish prompt displays whoami, hostname,
  the abbreviated working directory (returned by prompt_pwd),
  and ">"
  * abbreviated working directory returned by prompt_pwd isn't very useful
  * somewhat better if characters per path part is increased
    - defaults to 1
    - set fish_prompt_pwd_dir_length 3
- to customize, create ~/.config/fish/functions/fish_prompt.fish
  that echos the desired prompt
  * use set_color to control colors of various parts
  * can have multiple lines
- if custom prompt doesn't fit in terminal width,
  it will use just "> " instead
- ex.
function fish_prompt
  # Get the current Git branch.
  # This will be an empty string if not in a Git repo.
  set git_branch (git rev-parse --abbrev-ref HEAD ^/dev/null)

  # If in a Git repo (-q for quiet) ...
  if string length -q $git_branch
    set branch " ($git_branch)"
  else
    set branch ''
  end

  set_color --bold brblue
  echo -n $PWD # -n suppresses newline at end
  set_color --bold yellow
  echo $branch
  set_color normal
  echo -n '🐠  '
end
- can define a right prompt with the function fish_right_prompt
- can display Vim mode in prompt with the function fish_mode_prompt
  * ex. N for normal, I for insert, R for replace, and V for visuaul
  * see your functions/fish_mode_prompt.fish file
  * outputs a new prompt every time mode changes
    which is a bit distracting
    - make this an empty function to disable

Reading from stdin
- read var
  * waits for user to enter something, terminated by enter key
    - a single line
  * sets var to what user entered
- switches
  * --command text (-c)
    - sets initial text as if user had entered it
    - users can modify this
  * same switches as "set" for choosing scope of variable
    - includes -l (local), -g (global), -x (export), and -U (universal)
  * --silent (-i) to mask input (ex. for passwords)
  * --prompt-str text (-P)
    - sets prompt text
  * --prompt-cmd command (-p)
    - sets command that outputs the prompt
    - useful for dynamic prompts
  * --array (-a)
    - sets variable to a list of the words entered
  * --local (-l) makes variables local
  * --global (-g) makes variables global
  * --universal (-U) makes variables universal
  * --export (-x) exports variables
  * and many more
  * ex. read -P 'Favorite color: ' -c yellow color
- can have more than one variable
  * sets each to the word at the corresponding position
  * last variable gets all remaining words
  * ex. read first second
    - if user enters "foo bar baz",
      first is set to "foo" and
      second is set to "bar baz"
- to read lines from user until they press enter on an empty line
  while read line
    if test -z $line; break; end
    echo you entered $line
  end

Getting absolute path from a relative path
- realpath abs-path

Processes
- to get the current process id, %self
- to get the process id of the job with number n, %n
- to get the ids of all processes whose names begin with "prefix", $prefix

Jobs
- to run a command in background, add & to end of command
  * does not work for custom functions!
  * TODO: Why?
- to suspend currently running command, press ctrl-z
  * does not work for custom functions!
  * TODO: Why?
- to continue running a suspended command in background enter "bg"
- to get a list of background jobs and their job numbers, enter "jobs"
- to bring a background job back to the foreground,
  enter "fg" for the job most recently placed in background
  or "fg %job-number" for a specific job
  or "fg process-number"
- if you try to exit from a shell that has background jobs,
  it will warn about this and not exit
  * if you try to exit again,
    it will kill all the background jobs and exit

Debugging Functions
- add use of "breakpoint" commands in function
- run the function
- when a breakpoint is reached,
  the function will stop and control will be returned to the shell
- can examine and modify variables in the function
  * ex. echo $count
  * ex. set count 7
- to resume execution, enter "exit"
- to stop the running function before it reaches its end,
  enter "kill %self"

Random Numbers and Options
- random generates an integer in the range [0, 32767]
- argument meanings depend on number given
  * if 1, it is a seed
  * if 2, they are start and end of the range
    - ex. for a dice roll, random 1 6
  * if 3, they are start, step, and end
    - where only numbers that are increments of step from start
      will be generated
- to select a random item from a list of options
  * random choice option1 option2 ...
    - ex. random choice red green blue
    - ex.
      set colors red orange yellow green blue purple
      set color (random choice $colors)

TODO: Document how to use the "spin" function you installed.
    </div>
  </body>
</html>
